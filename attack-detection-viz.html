<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Attack Detection System</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f9f9f9;
            --bg-tertiary: #f0f0f0;
            --text-primary: #000000;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --border-color: #e0e0e0;
            --border-dark: #cccccc;
            --accent-danger: #000000;
            --accent-success: #333333;
            --shadow-soft: 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 2px 8px rgba(0, 0, 0, 0.12);
            --shadow-large: 0 8px 16px rgba(0, 0, 0, 0.15);

            --taskbar-height: 50px;
            --command-terminal-height: 50px;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            cursor: default;
        }

        body.dragging {
            cursor: move !important;
            user-select: none;
        }

        body.resizing-ns {
            cursor: ns-resize !important;
            user-select: none;
        }

        body.resizing-ew {
            cursor: ew-resize !important;
            user-select: none;
        }

        body.resizing-nwse {
            cursor: nwse-resize !important;
            user-select: none;
        }

        body.resizing-nesw {
            cursor: nesw-resize !important;
            user-select: none;
        }

        /* Animated background */
        #canvas-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* Header */
        .main-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 7000;
            background: #ffffff;
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-soft);
            height: 65px;
        }

        .nav-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: #000000;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            box-shadow: var(--shadow-medium);
        }

        .nav-menu {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .nav-item {
            padding: 8px 16px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
            letter-spacing: 0.3px;
        }

        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: #000000;
            color: #ffffff;
            font-weight: 600;
        }

        .nav-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .stats-bar {
            display: flex;
            gap: 20px;
            font-size: 12px;
            padding-right: 20px;
            border-right: 1px solid var(--border-color);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
        }

        .stat-label {
            color: var(--text-tertiary);
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 700;
            font-size: 15px;
        }

        .stat-value.danger {
            color: #000000;
            animation: pulse 2s infinite;
        }

        .stat-value.success {
            color: #333333;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'JetBrains Mono', monospace;
        }

        .action-btn.primary {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
            box-shadow: var(--shadow-medium);
        }

        .action-btn.primary:hover {
            background: #333333;
            border-color: #333333;
            box-shadow: var(--shadow-large);
            transform: translateY(-1px);
        }

        .action-btn.secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .action-btn.secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-dark);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: blink 2s infinite;
        }

        .status-indicator.online {
            background: #000000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Canvas workspace */
        #workspace {
            position: fixed;
            top: 65px;
            left: 250px;
            right: 0;
            bottom: calc(var(--taskbar-height) + var(--command-terminal-height));
            z-index: 1;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 65px;
            bottom: calc(var(--taskbar-height) + var(--command-terminal-height));
            width: 250px;
            background: #ffffff;
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            z-index: 6000;
            box-shadow: var(--shadow-soft);
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sidebar-filters {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .filter-item:hover {
            background: var(--border-color);
        }

        .filter-item.active {
            background: #000000;
            color: #ffffff;
        }

        .filter-checkbox {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .filter-item.active .filter-checkbox {
            background: #ffffff;
            border-color: #ffffff;
        }

        .filter-checkbox::after {
            content: '\2713';
            font-size: 10px;
            color: #000000;
            opacity: 0;
        }

        .filter-item.active .filter-checkbox::after {
            opacity: 1;
        }

        .quick-action {
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .quick-action:hover {
            background: var(--border-color);
            border-color: var(--border-dark);
            transform: translateX(2px);
        }

        .quick-action-icon {
            font-size: 16px;
        }

        .quick-action-text {
            flex: 1;
            font-weight: 500;
        }

        .model-info {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            font-size: 11px;
            line-height: 1.5;
        }

        .model-info-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 6px;
        }

        .model-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .model-metric-value {
            font-weight: 700;
            color: var(--text-primary);
        }

        .toggle-sidebar {
            position: fixed;
            left: 250px;
            top: 80px;
            width: 28px;
            height: 40px;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-left: none;
            border-radius: 0 4px 4px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 6100;
            transition: all 0.3s;
            box-shadow: var(--shadow-soft);
        }

        .toggle-sidebar:hover {
            background: var(--bg-tertiary);
        }

        .sidebar.collapsed {
            transform: translateX(-250px);
        }

        .sidebar.collapsed ~ .toggle-sidebar {
            left: 0;
        }

        .sidebar.collapsed ~ #workspace {
            left: 0;
        }

        /* Terminal windows */
        .terminal-window {
            position: absolute;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: var(--shadow-large);
            backdrop-filter: blur(10px);
            min-width: 300px;
            min-height: 200px;
            max-width: 95vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            cursor: default;
            transition: box-shadow 0.3s;
            z-index: 10;
            overflow: visible;
            animation: terminalOpen 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .terminal-window.no-animation {
            animation: none !important;
        }

        @keyframes terminalOpen {
            0% {
                opacity: 0;
                transform: translateY(100px) scale(0.8);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        /* macOS-style Genie Effect for Minimize - Smooth */
        @keyframes minimizeGenie {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.1) translateY(calc(100vh - 120px));
            }
        }
        
        /* macOS-style Restore from Dock - Smooth */
        @keyframes restoreGenie {
            0% {
                opacity: 0;
                transform: scale(0.1) translateY(calc(100vh - 120px));
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        /* macOS-style Maximize/Zoom */
        @keyframes maximizeZoom {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .terminal-window.minimizing {
            animation: minimizeGenie 0.3s ease-in forwards !important;
            pointer-events: none;
        }
        
        .terminal-window.restoring {
            animation: restoreGenie 0.3s ease-out forwards !important;
        }
        
        .terminal-window.maximizing {
            animation: maximizeZoom 0.2s ease-out !important;
        }

        .terminal-window.maximized {
            border-radius: 0;
            min-width: unset;
            min-height: unset;
            max-width: none;
            max-height: none;
        }
        
        .terminal-window.minimized {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.1) translateY(calc(100vh - 120px));
        }

        .terminal-window.resizing {
            user-select: none;
            transition: none;
            animation: none;
        }

        .terminal-window.no-animation {
            animation: none !important;
            transition: none !important;
        }

        .terminal-window:hover {
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.12);
        }

        .terminal-window.active {
            z-index: 50;
            border-color: #000000;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
        }

        /* VM Window Styles */
        .terminal-window[data-vm="attacker"] {
            border-color: #dc2626;
            box-shadow: 0 8px 24px rgba(220, 38, 38, 0.2);
        }
        
        .terminal-window[data-vm="attacker"] .terminal-header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-bottom-color: #dc2626;
        }
        
        .terminal-window[data-vm="attacker"] .terminal-title {
            color: #f87171;
        }
        
        .terminal-window[data-vm="attacker"] .terminal-content {
            background: #0f0f1a;
            color: #f87171;
        }
        
        .terminal-window[data-vm="victim"] {
            border-color: #16a34a;
            box-shadow: 0 8px 24px rgba(22, 163, 74, 0.2);
        }
        
        .terminal-window[data-vm="victim"] .terminal-header {
            background: linear-gradient(135deg, #0f1a0f 0%, #1a2e1a 100%);
            border-bottom-color: #16a34a;
        }
        
        .terminal-window[data-vm="victim"] .terminal-title {
            color: #4ade80;
        }
        
        .terminal-window[data-vm="victim"] .terminal-content {
            background: #0a140a;
            color: #4ade80;
        }
        
        /* VM Window Log Entry Overrides */
        .terminal-window[data-vm="attacker"] .log-entry,
        .terminal-window[data-vm="victim"] .log-entry {
            background: transparent;
            border-left: none;
            box-shadow: none;
            padding: 4px 8px;
            margin-bottom: 2px;
            animation: none;
        }
        
        .terminal-window[data-vm="attacker"] .log-entry.attack {
            background: transparent;
        }
        
        /* Terminal action buttons in VM windows */
        .terminal-window[data-vm="attacker"] .terminal-action-btn,
        .terminal-window[data-vm="victim"] .terminal-action-btn {
            color: #94a3b8;
        }
        
        .terminal-window[data-vm="attacker"] .terminal-action-btn:hover {
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        
        .terminal-window[data-vm="victim"] .terminal-action-btn:hover {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            z-index: 10;
        }

        .resize-handle.top {
            top: -5px;
            left: 10px;
            right: 10px;
            height: 10px;
            cursor: ns-resize;
        }

        .resize-handle.bottom {
            bottom: -5px;
            left: 10px;
            right: 10px;
            height: 10px;
            cursor: ns-resize;
        }

        .resize-handle.left {
            left: -5px;
            top: 45px;
            bottom: 10px;
            width: 10px;
            cursor: ew-resize;
        }

        .resize-handle.right {
            right: -5px;
            top: 45px;
            bottom: 10px;
            width: 10px;
            cursor: ew-resize;
        }

        .resize-handle.top-left {
            top: -5px;
            left: -5px;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
        }

        .resize-handle.top-right {
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-left {
            bottom: -5px;
            left: -5px;
            width: 20px;
            height: 20px;
            cursor: nesw-resize;
        }

        .resize-handle.bottom-right {
            bottom: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
        }

        /* Visible resize indicator on hover */
        .resize-handle::before {
            content: '';
            position: absolute;
            background: #000000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .terminal-window:hover .resize-handle.top::before,
        .terminal-window:hover .resize-handle.bottom::before {
            inset: 0;
            height: 3px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.3;
        }

        .terminal-window:hover .resize-handle.left::before,
        .terminal-window:hover .resize-handle.right::before {
            inset: 0;
            width: 3px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.3;
        }

        .terminal-window:hover .resize-handle.top-left::before,
        .terminal-window:hover .resize-handle.top-right::before,
        .terminal-window:hover .resize-handle.bottom-left::before,
        .terminal-window:hover .resize-handle.bottom-right::before {
            inset: 4px;
            border-radius: 50%;
            opacity: 0.5;
        }

        .resize-handle:hover::before {
            opacity: 0.8 !important;
        }

        /* Resize corner indicator - always visible in bottom-right */
        .resize-handle.bottom-right::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: 
                linear-gradient(135deg, transparent 0%, transparent 40%, #999999 40%, #999999 45%, transparent 45%, transparent 55%, #999999 55%, #999999 60%, transparent 60%);
            opacity: 0.5;
            pointer-events: none;
        }

        .terminal-window:hover .resize-handle.bottom-right::after {
            opacity: 0.8;
        }

        .terminal-header {
            background: var(--bg-secondary);
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 10px;
            cursor: move;
            border-radius: 3px 3px 0 0;
            user-select: none;
            position: relative;
            z-index: 11;
            min-height: 36px;
        }

        .terminal-title {
            font-weight: 500;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 0.3px;
            color: var(--text-primary);
            flex: 1;
            justify-content: flex-start;
            position: relative;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .terminal-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: blink 2s infinite;
        }

        .terminal-icon.green { 
            background: #333333;
            box-shadow: 0 0 8px rgba(51, 51, 51, 0.5);
        }
        .terminal-icon.red { 
            background: #000000;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
        }
        .terminal-icon.yellow { 
            background: #666666;
            box-shadow: 0 0 8px rgba(102, 102, 102, 0.5);
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        .terminal-controls {
            display: flex;
            gap: 8px;
            flex: 0 0 auto;
        }

        .terminal-btn {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: transparent;
            font-weight: bold;
            position: relative;
        }

        .terminal-btn::before {
            content: '';
            position: absolute;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .terminal-controls:hover .terminal-btn {
            color: rgba(0, 0, 0, 0.5);
        }

        .terminal-controls:hover .terminal-btn::before {
            opacity: 1;
        }

        .terminal-btn:hover {
            transform: scale(1.1);
        }

        .terminal-btn:active {
            transform: scale(0.9);
        }

        .terminal-btn.close { 
            background: #FF5F57;
            border: 0.5px solid #E0443E;
        }
        .terminal-btn.close::before {
            content: '×';
            font-size: 12px;
            line-height: 1;
        }
        
        .terminal-btn.minimize { 
            background: #FFBD2E;
            border: 0.5px solid #DEA123;
        }
        .terminal-btn.minimize::before {
            content: '−';
            font-size: 14px;
            line-height: 1;
        }
        
        .terminal-btn.maximize { 
            background: #28C940;
            border: 0.5px solid #1AAB29;
        }
        .terminal-btn.maximize::before {
            content: '+';
            font-size: 11px;
            line-height: 1;
        }

        /* Smooth window animations */
        .terminal-window {
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                        left 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        top 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        width 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        height 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        border-radius 0.2s ease,
                        box-shadow 0.2s ease;
        }

        /* Disable transitions during drag/resize */
        .terminal-window.dragging,
        .terminal-window.resizing {
            transition: box-shadow 0.2s ease;
        }

        .terminal-window.minimizing {
            transform: scale(0.2) translateY(calc(100vh - 100px));
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.4, 0, 1, 1), opacity 0.3s ease;
        }

        .terminal-window.minimized {
            transform: scale(0) translateY(calc(100vh - 50px));
            opacity: 0;
            pointer-events: none;
        }

        .terminal-window.restoring {
            animation: restoreWindow 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes restoreWindow {
            0% {
                transform: scale(0.2) translateY(calc(100vh - 100px));
                opacity: 0;
            }
            60% {
                transform: scale(1.02) translateY(0);
                opacity: 1;
            }
            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        /* Windows 11 Edge Snap Preview */
        .snap-preview {
            position: fixed;
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.6);
            border-radius: 8px;
            z-index: 9000;
            pointer-events: none;
            opacity: 0;
            transition: all 0.15s ease;
        }
        .snap-preview.visible {
            opacity: 1;
        }

        /* Maximize animation */
        .terminal-window.maximizing {
            animation: maximizeWindow 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes maximizeWindow {
            from { border-radius: 8px; }
            to { border-radius: 0; }
        }

        .terminal-window.maximized {
            position: fixed !important;
            top: 65px !important;
            left: 250px !important;
            width: calc(100vw - 250px) !important;
            height: calc(100vh - 115px) !important;
            border-radius: 0 !important;
            z-index: 8000 !important;
        }
        .sidebar.collapsed ~ #workspace .terminal-window.maximized {
            left: 0 !important;
            width: 100vw !important;
        }

        .terminal-window.closing {
            animation: closeWindow 0.2s cubic-bezier(0.4, 0, 1, 1) forwards;
        }

        @keyframes closeWindow {
            to {
                transform: scale(0.8);
                opacity: 0;
            }
        }
        
        /* Snap animation */
        .terminal-window.snapping {
            animation: snapWindow 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes snapWindow {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .terminal-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.6;
            font-family: 'JetBrains Mono', 'Consolas', 'Courier New', monospace;
            background: #ffffff;
            color: var(--text-primary);
            min-height: 0;
            user-select: text;
            cursor: text;
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) var(--bg-tertiary);
            scroll-behavior: smooth;
        }

        .terminal-content::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: var(--border-dark);
            border-radius: 5px;
            border: 2px solid var(--bg-tertiary);
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        
        .terminal-content::-webkit-scrollbar-corner {
            background: var(--bg-tertiary);
        }

        /* Scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            z-index: 5;
            display: none;
            animation: bounce 1s infinite;
        }
        .scroll-indicator.visible { display: block; }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        /* Minimal Alert Row Styles */
        .alert-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            margin: 3px 0;
            background: linear-gradient(90deg, rgba(220, 38, 38, 0.15) 0%, rgba(220, 38, 38, 0.05) 100%);
            border-left: 4px solid #dc2626;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        .alert-row:hover { background: linear-gradient(90deg, rgba(220, 38, 38, 0.25) 0%, rgba(220, 38, 38, 0.1) 100%); }
        .alert-id { color: #64748b; min-width: 35px; font-weight: 500; }
        .alert-type { color: #dc2626; font-weight: 700; min-width: 100px; text-transform: uppercase; }
        .alert-conf { color: #d97706; font-weight: 600; min-width: 40px; background: rgba(217, 119, 6, 0.15); padding: 2px 6px; border-radius: 3px; }
        .alert-flow { color: #1e293b; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; }
        .alert-mitre { color: #7c3aed; font-size: 11px; font-weight: 600; background: rgba(124, 58, 237, 0.1); padding: 2px 8px; border-radius: 3px; }

        /* Snap Layout Grid Overlay */
        /* Windows 11 Style Snap Layout */
        .snap-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 0 0 1px rgba(0,0,0,0.1);
            z-index: 9500;
            display: none;
            padding: 16px;
            width: 320px;
        }
        .snap-overlay.active { display: block; animation: snapFadeIn 0.15s ease-out; }
        @keyframes snapFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .snap-overlay-title {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
            text-align: center;
            font-weight: 500;
        }
        .snap-layouts {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        .snap-layout-option {
            display: flex;
            flex-direction: column;
            gap: 3px;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .snap-layout-option:hover { background: #f0f0f0; }
        .snap-layout-option.selected { background: #e0e7ff; }
        .snap-layout-preview {
            width: 48px;
            height: 36px;
            display: grid;
            gap: 2px;
            border-radius: 3px;
            overflow: hidden;
        }
        .snap-layout-preview div {
            background: #c4c4c4;
            border-radius: 2px;
            transition: background 0.15s;
        }
        .snap-layout-option:hover .snap-layout-preview div { background: #0078d4; }
        .snap-layout-option:hover .snap-layout-preview div.highlight { background: #0078d4; }
        
        /* Layout previews */
        .snap-preview-half { grid-template-columns: 1fr 1fr; }
        .snap-preview-thirds { grid-template-columns: 1fr 1fr 1fr; }
        .snap-preview-quarter { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .snap-preview-left-large { grid-template-columns: 2fr 1fr; }
        .snap-preview-right-large { grid-template-columns: 1fr 2fr; }
        .snap-preview-full { grid-template-columns: 1fr; }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: var(--shadow-large);
            padding: 4px;
            z-index: 10000;
            min-width: 180px;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: var(--bg-tertiary);
        }

        .context-menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-icon {
            font-size: 14px;
            width: 16px;
        }

        .context-menu-shortcut {
            margin-left: auto;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Search bar in terminal */
        .terminal-search {
            position: absolute;
            top: 45px;
            right: 15px;
            display: none;
            background: #ffffff;
            border: 1px solid #000000;
            border-radius: 4px;
            padding: 6px 10px;
            box-shadow: var(--shadow-medium);
            z-index: 12;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .terminal-search.active {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terminal-search input {
            border: none;
            outline: none;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            width: 200px;
            color: var(--text-primary);
        }

        .terminal-search-controls {
            display: flex;
            gap: 4px;
        }

        .terminal-search-btn {
            background: transparent;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .terminal-search-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .terminal-search-count {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .highlight-search {
            background: #ffff00;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .highlight-search.current {
            background: #cccc00;
        }

        /* Copy notification */
        .copy-notification {
            position: fixed;
            top: 80px;
            right: 30px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 4px;
            padding: 12px 20px;
            box-shadow: var(--shadow-large);
            animation: slideInRight 0.3s ease-out;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Terminal actions toolbar */
        .terminal-actions {
            display: flex;
            gap: 4px;
            flex: 0 0 auto;
        }

        .terminal-action-btn {
            background: transparent;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .terminal-action-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        .terminal-action-btn:active {
            transform: scale(0.95);
        }

        /* Log entries */
        .log-entry {
            margin-bottom: 20px;
            padding: 15px 18px;
            border-left: 3px solid transparent;
            background: #fafafa;
            border-radius: 4px;
            animation: slideIn 0.2s ease-out;
            font-family: 'JetBrains Mono', monospace;
            border-bottom: 1px solid #e2e8f0;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-entry.normal {
            border-left-color: #4a5568;
            background: #f7fafc;
        }

        .log-entry.warning {
            border-left-color: #d69e2e;
            background: #fffff0;
        }

        .log-entry.attack {
            border-left-color: #e53e3e;
            background: #fff5f5;
        }

        .log-timestamp {
            display: block;
            color: #718096;
            font-size: 11px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .log-type {
            display: inline-block;
            font-weight: 700;
            font-size: 11px;
            text-transform: uppercase;
            margin-right: 10px;
            padding: 3px 8px;
            border-radius: 3px;
            background: #e2e8f0;
            color: #2d3748;
        }

        .log-entry.warning .log-type {
            background: #faf089;
            color: #744210;
        }

        .log-entry.attack .log-type {
            background: #fed7d7;
            color: #c53030;
        }

        .log-message {
            display: block;
            color: #1a202c;
            margin-top: 10px;
            line-height: 1.6;
            word-break: break-word;
        }

        /* Processing window specific styles */
        .process-step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            margin-bottom: 10px;
            background: #ffffff;
            border-radius: 4px;
            border-left: 3px solid #000000;
            box-shadow: var(--shadow-soft);
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
            box-shadow: var(--shadow-medium);
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 700;
            color: #000000;
            margin-bottom: 3px;
            font-size: 13px;
        }

        .step-detail {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .progress-bar {
            height: 5px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: #000000;
            animation: progress 2s ease-in-out infinite;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        @keyframes progress {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        /* Dashboard views */
        .dashboard-view {
            position: fixed;
            top: 65px;
            left: 250px;
            right: 0;
            bottom: calc(var(--taskbar-height) + var(--command-terminal-height));
            background: #ffffff;
            padding: 30px;
            overflow-y: auto;
            z-index: 5;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .dashboard-view.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        .dashboard-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dashboard-actions {
            display: flex;
            gap: 10px;
        }

        .dashboard-btn {
            padding: 10px 20px;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'JetBrains Mono', monospace;
        }

        .dashboard-btn:hover {
            background: #000000;
            color: #ffffff;
            border-color: #000000;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .dashboard-card {
            background: #ffffff;
            border-radius: 4px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }

        .dashboard-card:hover {
            box-shadow: var(--shadow-medium);
            transform: translateY(-2px);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .card-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .card-icon {
            font-size: 24px;
        }

        .card-value {
            font-size: 32px;
            font-weight: 700;
            color: #000000;
            margin-bottom: 8px;
        }

        .card-label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .card-trend {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 3px;
            margin-top: 8px;
        }

        .card-trend.up {
            background: #e8e8e8;
            color: #000000;
        }

        .card-trend.down {
            background: #f5f5f5;
            color: #333333;
        }

        .threat-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .threat-item {
            padding: 12px;
            border-left: 3px solid;
            background: #fafafa;
            margin-bottom: 10px;
            border-radius: 3px;
            font-size: 13px;
        }

        .threat-item.critical {
            border-left-color: #000000;
            background: #f0f0f0;
        }

        .threat-item.high {
            border-left-color: #333333;
            background: #f5f5f5;
        }

        .threat-item.medium {
            border-left-color: #666666;
            background: #fafafa;
        }

        .threat-title {
            font-weight: 700;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .threat-details {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .chart-container {
            background: #ffffff;
            border-radius: 4px;
            padding: 24px;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .bar-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .bar-label {
            min-width: 120px;
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .bar-track {
            flex: 1;
            height: 24px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            background: #000000;
            transition: width 0.6s ease-out;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            color: #ffffff;
            font-size: 12px;
            font-weight: 700;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .metric-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .metric-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .report-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .report-item {
            padding: 16px;
            background: #ffffff;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .report-item:hover {
            background: var(--bg-tertiary);
            border-color: #000000;
        }

        .report-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .report-icon {
            font-size: 24px;
        }

        .report-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .report-date {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .report-download {
            padding: 8px 16px;
            background: #000000;
            color: #ffffff;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'JetBrains Mono', monospace;
        }

        .report-download:hover {
            background: #333333;
        }

        /* Alert notification */
        .alert-notification {
            position: fixed;
            top: 100px;
            right: 30px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 4px;
            padding: 20px;
            max-width: 350px;
            box-shadow: var(--shadow-large);
            animation: slideInRight 0.5s ease-out, shakeBounce 0.5s ease-out 0.5s;
            z-index: 200;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes shakeBounce {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .alert-title {
            font-size: 18px;
            font-weight: 900;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #000000;
        }

        .alert-details {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        /* Network visualization */
        .network-node {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #000000;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            animation: float 3s ease-in-out infinite;
            pointer-events: none;
        }

        .network-node.attack {
            background: #000000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            animation: float 3s ease-in-out infinite, attackGlow 1s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        @keyframes attackGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); }
            50% { box-shadow: 0 0 40px rgba(0, 0, 0, 1); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .terminal-window {
                min-width: 300px;
                min-height: 250px;
            }
            
            .stats-bar {
                gap: 15px;
            }

            .sidebar {
                transform: translateX(-250px);
            }

            .toggle-sidebar {
                left: 0;
            }

            #workspace {
                left: 0;
            }

            .nav-menu {
                display: none;
            }
        }

        @media (max-width: 1200px) {
            .nav-menu {
                gap: 2px;
            }

            .nav-item {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        /* Tooltip */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            font-size: 11px;
            border-radius: 3px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 1000;
        }

        [data-tooltip]::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-2px);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 1000;
        }

        [data-tooltip]:hover::after,
        [data-tooltip]:hover::before {
            opacity: 1;
            transform: translateX(-50%) translateY(-4px);
        }

        /* Focus styles */
        button:focus-visible,
        .nav-item:focus-visible,
        .filter-item:focus-visible {
            outline: 2px solid #000000;
            outline-offset: 2px;
        }

        /* Selection color */
        ::selection {
            background: #000000;
            color: #ffffff;
        }

        /* Taskbar */
        .taskbar {
            position: fixed;
            bottom: var(--command-terminal-height);
            left: 0;
            right: 0;
            height: 50px;
            background: #ffffff;
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 8px;
            z-index: 8000;
            box-shadow: var(--shadow-soft);
        }

        /* Command Terminal at Bottom */
        .command-terminal {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--command-terminal-height);
            background: #000000;
            border-top: 2px solid #333333;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 6px 20px;
            gap: 10px;
            z-index: 9000;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
            transition: height 0.3s ease;
            position: fixed;
            contain: layout paint;
        }

        .command-terminal.expanded {
            padding: 12px 20px;
        }

        .command-input-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 0 0 auto;
        }

        .command-resize-handle {
            position: absolute;
            top: -6px;
            left: 0;
            right: 0;
            height: 12px;
            cursor: ns-resize;
            z-index: 9001;
        }

        .command-resize-handle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 6px;
            transform: translateX(-50%);
            width: 42px;
            height: 4px;
            border-radius: 999px;
            background: rgba(200, 200, 200, 0.5);
        }

        .command-prompt {
            color: #00ff00;
            font-weight: 700;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .command-input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            outline: none;
            padding: 8px 0;
        }

        .command-input::placeholder {
            color: #666666;
        }

        .command-toggle {
            background: transparent;
            border: none;
            color: #666666;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 18px;
            transition: color 0.2s;
        }

        .command-toggle:hover {
            color: #ffffff;
        }

        .command-output {
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            color: #cccccc;
            font-size: 12px;
            line-height: 1.6;
            display: none;
            margin: 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
        }

        .command-terminal.expanded .command-output {
            display: block;
        }

        .command-terminal.expanded .command-output {
            margin-bottom: 6px;
        }

        .command-line {
            margin-bottom: 5px;
            display: flex;
            gap: 10px;
        }

        .command-line.error {
            color: #ff6666;
        }

        .command-line.success {
            color: #66ff66;
        }

        .command-line.info {
            color: #6699ff;
        }

        .command-help {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #ffffff;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
        }

        .command-help-title {
            color: #ffffff;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .command-help-item {
            display: flex;
            gap: 15px;
            margin: 3px 0;
            font-size: 11px;
        }

        .command-help-cmd {
            color: #66ff66;
            font-weight: 700;
            min-width: 120px;
        }

        .command-help-desc {
            color: #999999;
        }

        .taskbar-start {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: auto;
        }

        .taskbar-logo {
            width: 32px;
            height: 32px;
            background: #000000;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: var(--shadow-medium);
        }

        .taskbar-logo:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-large);
        }

        .taskbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 5px;
        }

        .taskbar-items {
            display: flex;
            gap: 6px;
            flex: 1;
        }

        .taskbar-item {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            position: relative;
        }

        .taskbar-item::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #000000;
            transform: scaleX(0);
            transition: transform 0.2s;
        }

        .taskbar-item:hover {
            background: var(--border-color);
            border-color: var(--border-dark);
            transform: translateY(-2px);
        }

        .taskbar-item.active::before {
            transform: scaleX(1);
        }

        .taskbar-item.active {
            background: #f5f5f5;
            border-color: #000000;
            font-weight: 600;
        }

        .taskbar-item .terminal-icon {
            flex-shrink: 0;
        }

        .taskbar-end {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-left: auto;
            padding-left: 15px;
            border-left: 1px solid var(--border-color);
        }

        .taskbar-time {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .taskbar-system-tray {
            display: flex;
            gap: 8px;
        }

        .system-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .system-icon:hover {
            background: var(--border-color);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <!-- Animated background canvas -->
    <canvas id="canvas-bg"></canvas>

    <!-- Header -->
    <header class="main-header">
        <div class="nav-left">
            <div class="logo">
                <div class="logo-icon"><i class="fas fa-shield-alt"></i></div>
                CYBERDEFENSE.AI
            </div>
            <nav class="nav-menu">
                <a class="nav-item active">Dashboard</a>
                <a class="nav-item">Live Monitor</a>
                <a class="nav-item">Analytics</a>
                <a class="nav-item">Threats</a>
                <a class="nav-item">Reports</a>
            </nav>
        </div>
        <div class="nav-right">
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-label">Total Flows</div>
                    <div class="stat-value" id="total-flows">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Attacks</div>
                    <div class="stat-value danger" id="attacks-detected">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Detection Rate</div>
                    <div class="stat-value success" id="detection-rate">0%</div>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-btn secondary" id="settings-btn">
                    <i class="fas fa-cog"></i> Settings
                </button>
                <button class="action-btn primary" id="export-btn">
                    <i class="fas fa-download"></i> Export
                </button>
                <div style="display: flex; align-items: center; gap: 8px; padding: 0 8px;">
                    <span class="status-indicator online"></span>
                    <span style="font-size: 11px; color: var(--text-secondary); font-weight: 600;">LIVE</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title"><i class="fas fa-filter"></i> ATTACK FILTERS</div>
            <div class="filter-group">
                <div class="filter-item active" data-filter="all">
                    <div class="filter-checkbox"></div>
                    <span>Show All</span>
                </div>
                <div class="filter-item" data-filter="dos">
                    <div class="filter-checkbox"></div>
                    <span>DoS Attacks</span>
                </div>
                <div class="filter-item" data-filter="malware">
                    <div class="filter-checkbox"></div>
                    <span>Malware</span>
                </div>
                <div class="filter-item" data-filter="worm">
                    <div class="filter-checkbox"></div>
                    <span>Worms</span>
                </div>
                <div class="filter-item" data-filter="exploit">
                    <div class="filter-checkbox"></div>
                    <span>Exploits</span>
                </div>
                <div class="filter-item" data-filter="recon">
                    <div class="filter-checkbox"></div>
                    <span>Reconnaissance</span>
                </div>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title"><i class="fas fa-bolt"></i> QUICK ACTIONS</div>
            <div class="quick-action" id="clear-logs">
                <span class="quick-action-icon"><i class="fas fa-trash"></i></span>
                <span class="quick-action-text">Clear All Logs</span>
            </div>
            <div class="quick-action" id="pause-detection">
                <span class="quick-action-icon"><i class="fas fa-pause"></i></span>
                <span class="quick-action-text">Pause Detection</span>
            </div>
            <div class="quick-action" id="export-data">
                <span class="quick-action-icon"><i class="fas fa-save"></i></span>
                <span class="quick-action-text">Export Data</span>
            </div>
            <div class="quick-action" id="screenshot">
                <span class="quick-action-icon"><i class="fas fa-camera"></i></span>
                <span class="quick-action-text">Screenshot</span>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title"><i class="fas fa-brain"></i> MODEL INFO</div>
            <div class="model-info">
                <div class="model-info-title">Random Forest Classifier</div>
                <div class="model-metric">
                    <span>Accuracy:</span>
                    <span class="model-metric-value" style="color: #333;">97.11%</span>
                </div>
                <div class="model-metric">
                    <span>Classes:</span>
                    <span class="model-metric-value">10</span>
                </div>
                <div class="model-metric">
                    <span>Training:</span>
                    <span class="model-metric-value">2.5M samples</span>
                </div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color);">
                    <div class="model-metric">
                        <span>Dataset:</span>
                        <span class="model-metric-value">UNSW-NB15</span>
                    </div>
                    <div class="model-metric">
                        <span>Features:</span>
                        <span class="model-metric-value">41</span>
                    </div>
                </div>
            </div>
        </div>
    </aside>

    <button class="toggle-sidebar" id="toggle-sidebar">
        <i class="fas fa-chevron-left"></i>
    </button>

    <!-- Workspace -->
    <div id="workspace"></div>

    <!-- Live Monitor Dashboard View -->
    <div class="dashboard-view" id="view-live-monitor">
        <div class="dashboard-header">
            <div class="dashboard-title">
                <span>📡</span>
                Live Network Monitor
            </div>
            <div class="dashboard-actions">
                <button class="dashboard-btn" onclick="location.reload()">
                    <span>🔄</span>
                    Refresh
                </button>
                <button class="dashboard-btn" onclick="sendSocCommand('/status')">
                    <i class="fas fa-cog"></i>
                    Status
                </button>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Total Flows</div>
                    <div class="card-icon"><i class="fas fa-chart-bar"></i></div>
                </div>
                <div class="card-value" id="live-total-flows">0</div>
                <div class="card-label">Network flows processed</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Attacks Detected</div>
                    <div class="card-icon"><i class="fas fa-exclamation-circle"></i></div>
                </div>
                <div class="card-value" style="color: #000000;" id="live-attacks">0</div>
                <div class="card-label">Malicious activities detected</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Detection Rate</div>
                    <div class="card-icon"><i class="fas fa-chart-line"></i></div>
                </div>
                <div class="card-value" style="font-size: 24px;" id="live-detection-rate">0%</div>
                <div class="card-label">Attack to flow ratio</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">System Status</div>
                    <div class="card-icon"><i class="fas fa-check-circle"></i></div>
                </div>
                <div class="metric-grid">
                    <div class="metric-item">
                        <div class="metric-label">Zeek Sensor</div>
                        <div class="metric-value" id="live-zeek-status" style="color: #333;">UNKNOWN</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Replay</div>
                        <div class="metric-value" id="live-replay-status" style="color: var(--text-secondary);">IDLE</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">ML Model</div>
                        <div class="metric-value" style="color: #333;">ACTIVE</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">WebSocket</div>
                        <div class="metric-value" id="live-ws-status" style="color: var(--text-secondary);">CONNECTING</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">Quick Actions</div>
            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                <button class="dashboard-btn" onclick="sendSocCommand('/zeek start')">▶️ Start Zeek</button>
                <button class="dashboard-btn" onclick="sendSocCommand('/zeek stop')">⏹️ Stop Zeek</button>
                <button class="dashboard-btn" onclick="sendSocCommand('/attack')"><i class="fas fa-exclamation-circle"></i> Simulate Attack</button>
                <button class="dashboard-btn" onclick="sendSocCommand('/stats')"><i class="fas fa-chart-bar"></i> Get Stats</button>
                <button class="dashboard-btn" onclick="sendSocCommand('/export json')"><i class="fas fa-floppy-disk"></i> Export JSON</button>
                <button class="dashboard-btn" onclick="sendSocCommand('/clear')"><i class="fas fa-trash"></i> Clear State</button>
            </div>
        </div>
    </div>

    <!-- Analytics Dashboard View -->
    <div class="dashboard-view" id="view-analytics">
        <div class="dashboard-header">
            <div class="dashboard-title">
                <span><i class="fas fa-chart-bar"></i></span>
                Analytics Dashboard
            </div>
            <div class="dashboard-actions">
                <button class="dashboard-btn" onclick="sendSocCommand('/export json')">
                    <span><i class="fas fa-download"></i></span>
                    Export Data
                </button>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Total Attacks</div>
                    <div class="card-icon"><i class="fas fa-exclamation-circle"></i></div>
                </div>
                <div class="card-value" style="color: #000000;" id="analytics-total-attacks">0</div>
                <div class="card-label">ML-detected attacks this session</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Attack Types</div>
                    <div class="card-icon">📦</div>
                </div>
                <div class="card-value" style="font-size: 24px;" id="analytics-unique-types">0</div>
                <div class="card-label">Unique attack categories detected</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Model</div>
                    <div class="card-icon"><i class="fas fa-brain"></i></div>
                </div>
                <div class="card-value" style="font-size: 18px;">Random Forest</div>
                <div class="card-label">Binary (Normal/Attack, 97.11% acc)</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Features</div>
                    <div class="card-icon">⚡</div>
                </div>
                <div class="card-value" style="font-size: 24px;">41</div>
                <div class="card-label">Network features (no data leakage)</div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">Attack Categories Detected (Live)</div>
            <div class="bar-chart" id="analytics-attack-chart">
                <div style="color: #64748b; padding: 20px; text-align: center;">
                    No attacks detected yet. Run <code>/attack</code> to simulate attacks.
                </div>
            </div>
        </div>
    </div>

    <!-- Threats Dashboard View -->
    <div class="dashboard-view" id="view-threats">
        <div class="dashboard-header">
            <div class="dashboard-title">
                <span><i class="fas fa-exclamation-triangle"></i></span>
                Threat Intelligence
            </div>
            <div class="dashboard-actions">
                <button class="dashboard-btn" onclick="sendSocCommand('/stats')">
                    <span>🔄</span>
                    Refresh Stats
                </button>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Active Alerts</div>
                    <div class="card-icon">🔴</div>
                </div>
                <div class="card-value" style="color: #000000;" id="threat-active-alerts">0</div>
                <div class="card-label">Requiring analyst review</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">MITRE Techniques</div>
                    <div class="card-icon"><i class="fas fa-shield-alt"></i></div>
                </div>
                <div class="card-value" style="color: #666666;" id="threat-mitre-count">0</div>
                <div class="card-label">Unique techniques observed</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Alert States</div>
                    <div class="card-icon">📡</div>
                </div>
                <div class="card-value" style="font-size: 20px;">5</div>
                <div class="card-label">new → investigating → confirmed/fp → closed</div>
            </div>

            <div class="dashboard-card">
                <div class="card-header">
                    <div class="card-title">Explainability</div>
                    <div class="card-icon">💡</div>
                </div>
                <div class="card-value" style="font-size: 20px; color: #333;">XAI</div>
                <div class="card-label">Why flagged + Zeek evidence</div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">MITRE ATT&CK Techniques Observed (Live)</div>
            <ul class="threat-list" id="mitre-threat-list">
                <li class="threat-item medium">
                    <div class="threat-title">🟡 No techniques observed yet</div>
                    <div class="threat-details">Run <code>/attack</code> to simulate attacks and see MITRE mappings</div>
                </li>
            </ul>
        </div>
    </div>

    <!-- Reports Dashboard View -->
    <div class="dashboard-view" id="view-reports">
        <div class="dashboard-header">
            <div class="dashboard-title">
                <span><i class="fas fa-file-alt"></i></span>
                Security Reports
            </div>
            <div class="dashboard-actions">
                <button class="dashboard-btn" onclick="sendSocCommand('/export json')">
                    <span><i class="fas fa-plus"></i></span>
                    Export JSON
                </button>
                <button class="dashboard-btn" onclick="sendSocCommand('/export csv')">
                    <span><i class="fas fa-chart-bar"></i></span>
                    Export CSV
                </button>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-title">Export Options</div>
            <ul class="report-list">
                <li class="report-item" onclick="sendSocCommand('/export json')">
                    <div class="report-info">
                        <div class="report-icon"><i class="fas fa-chart-line"></i></div>
                        <div>
                            <div class="report-name">JSON Export</div>
                            <div class="report-date">Full alert data with lifecycle fields</div>
                        </div>
                    </div>
                    <button class="report-download">Generate</button>
                </li>
                <li class="report-item" onclick="sendSocCommand('/export csv')">
                    <div class="report-info">
                        <div class="report-icon"><i class="fas fa-chart-line"></i></div>
                        <div>
                            <div class="report-name">CSV Export</div>
                            <div class="report-date">Spreadsheet-compatible format</div>
                        </div>
                    </div>
                    <button class="report-download">Generate</button>
                </li>
            </ul>
        </div>

        <div class="chart-container" style="margin-top: 20px;">
            <div class="chart-title">Alert Lifecycle Commands</div>
            <ul class="report-list">
                <li class="report-item">
                    <div class="report-info">
                        <div class="report-icon">📝</div>
                        <div>
                            <div class="report-name">/note &lt;id&gt; &lt;text&gt;</div>
                            <div class="report-date">Add analyst notes to an alert</div>
                        </div>
                    </div>
                </li>
                <li class="report-item">
                    <div class="report-info">
                        <div class="report-icon">🏷️</div>
                        <div>
                            <div class="report-name">/tag &lt;id&gt; &lt;tag&gt;</div>
                            <div class="report-date">Add tags to categorize alerts</div>
                        </div>
                    </div>
                </li>
                <li class="report-item">
                    <div class="report-info">
                        <div class="report-icon">🔄</div>
                        <div>
                            <div class="report-name">/state &lt;id&gt; &lt;state&gt;</div>
                            <div class="report-date">Change alert state (new, investigating, confirmed, false_positive, closed)</div>
                        </div>
                    </div>
                </li>
            </ul>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="context-copy">
            <span class="context-menu-icon">📋</span>
            <span>Copy</span>
            <span class="context-menu-shortcut">Ctrl+C</span>
        </div>
        <div class="context-menu-item" id="context-paste">
            <span class="context-menu-icon">📄</span>
            <span>Paste</span>
            <span class="context-menu-shortcut">Ctrl+V</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="context-search">
            <span class="context-menu-icon"><i class="fas fa-search"></i></span>
            <span>Search</span>
            <span class="context-menu-shortcut">Ctrl+F</span>
        </div>
        <div class="context-menu-item" id="context-select-all">
            <span class="context-menu-icon">📑</span>
            <span>Select All</span>
            <span class="context-menu-shortcut">Ctrl+A</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="context-clear">
            <span class="context-menu-icon">🗑️</span>
            <span>Clear Terminal</span>
        </div>
    </div>

    <!-- Command Terminal -->
    <div class="command-terminal" id="command-terminal">
        <div class="command-resize-handle" id="command-resize-handle" title="Drag to resize"></div>
        <div class="command-output" id="command-output">
            <div class="command-line info"><i class="fas fa-shield-alt"></i> Welcome to CyberDefense.AI Command Terminal</div>
            <div class="command-line info">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</div>
            <div class="command-line success">✓ System initialized successfully</div>
            <div class="command-line" style="margin-top: 10px;">
                <span style="color: #94a3b8;">Type </span>
                <span style="color: #00aa00; font-weight: 700;">/help</span>
                <span style="color: #94a3b8;"> to see all available commands</span>
            </div>
            <div class="command-line" style="margin-top: 5px;">
                <span style="color: #94a3b8;">Quick start: </span>
                <span style="color: #0066cc; font-weight: 700;">/open attack</span>
                <span style="color: #94a3b8;"> or </span>
                <span style="color: #0066cc; font-weight: 700;">/open monitor</span>
            </div>
        </div>

        <div class="command-input-row" id="command-input-row">
            <div class="command-prompt">
                <span>➜</span>
                <span style="color: #60a5fa;">cyberdefense</span>
                <span style="color: #64748b;">~</span>
            </div>
            <div class="command-input-wrapper">
                <input 
                    type="text" 
                    class="command-input" 
                    id="command-input"
                    placeholder="Type '/help' for available commands..."
                    autocomplete="off"
                    spellcheck="false"
                />
            </div>
            <button class="command-toggle" id="command-toggle" title="Toggle Command History">▲</button>
        </div>
    </div>

    <!-- Windows 11 Edge Snap Preview -->
    <div class="snap-preview" id="snap-preview"></div>

    <!-- Windows 11 Style Snap Layout Overlay -->
    <div class="snap-overlay" id="snap-overlay"></div>
        <div class="snap-overlay-title">Snap layouts</div>
        <div class="snap-layouts">
            <!-- 2 columns: Left/Right half -->
            <div class="snap-layout-option" data-layout="half">
                <div class="snap-layout-preview snap-preview-half">
                    <div data-snap="left"></div>
                    <div data-snap="right"></div>
                </div>
            </div>
            <!-- 3 columns -->
            <div class="snap-layout-option" data-layout="thirds">
                <div class="snap-layout-preview snap-preview-thirds">
                    <div data-snap="left-third"></div>
                    <div data-snap="center-third"></div>
                    <div data-snap="right-third"></div>
                </div>
            </div>
            <!-- 4 quarters -->
            <div class="snap-layout-option" data-layout="quarters">
                <div class="snap-layout-preview snap-preview-quarter">
                    <div data-snap="top-left"></div>
                    <div data-snap="top-right"></div>
                    <div data-snap="bottom-left"></div>
                    <div data-snap="bottom-right"></div>
                </div>
            </div>
            <!-- Left large + right small -->
            <div class="snap-layout-option" data-layout="left-large">
                <div class="snap-layout-preview snap-preview-left-large">
                    <div data-snap="left-large"></div>
                    <div data-snap="right-small"></div>
                </div>
            </div>
            <!-- Full screen -->
            <div class="snap-layout-option" data-layout="full">
                <div class="snap-layout-preview snap-preview-full">
                    <div data-snap="full"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Taskbar -->
    <div class="taskbar" id="taskbar">
        <div class="taskbar-start">
            <div class="taskbar-logo" title="CyberDefense.AI"><i class="fas fa-shield-alt"></i></div>
            <div class="taskbar-divider"></div>
        </div>
        <div class="taskbar-items" id="taskbar-items"></div>
        <div class="taskbar-end">
            <div class="taskbar-system-tray">
                <div class="system-icon" id="taskbar-add-terminal" title="New terminal">+</div>
                <div class="system-icon" id="snap-layout-btn" title="Snap Layout (Win+Z)">⊞</div>
            </div>
            <div class="taskbar-time" id="taskbar-time">00:00:00</div>
        </div>
    </div>

    <script>
        // Global terminals array - stores all open terminal windows
        const terminals = [];
        
        // Currently active (focused) terminal
        let activeTerminal = null;
        
        // Background canvas animation
        const canvas = document.getElementById('canvas-bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 2 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(37, 99, 235, 0.15)';
                ctx.fill();
            }
        }

        const particles = Array.from({ length: 50 }, () => new Particle());

        function animateBackground() {
            ctx.fillStyle = 'rgba(245, 247, 250, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            // Draw connections
            particles.forEach((p1, i) => {
                particles.slice(i + 1).forEach(p2 => {
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 150) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.strokeStyle = `rgba(37, 99, 235, ${0.15 * (1 - distance / 150)})`;
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                });
            });

            requestAnimationFrame(animateBackground);
        }

        animateBackground();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // STRICT: Only allow these 3 window types during attack simulation
        const ALLOWED_WINDOWS = new Set(['vm-attacker', 'vm-victim', 'attack', 'process', 'monitor']);
        
        function isWindowAllowed(type) {
            return ALLOWED_WINDOWS.has(type);
        }
        
        function closeAllExtraWindows() {
            // Close any windows that aren't in the allowed set
            terminals.forEach(t => {
                if (!isWindowAllowed(t.type)) {
                    const elem = t.element;
                    if (elem) {
                        elem.classList.add('closing');
                        setTimeout(() => {
                            elem.remove();
                            const idx = terminals.indexOf(t);
                            if (idx > -1) terminals.splice(idx, 1);
                        }, 200);
                    }
                }
            });
        }
        // Keep draggable windows below UI chrome (sidebar/header/taskbar/command bar)
        const Z_WINDOW_BASE = 2000;
        const Z_WINDOW_MAX = 5999;
        let zIndexCounter = Z_WINDOW_BASE;

        function nextWindowZ() {
            zIndexCounter = (zIndexCounter >= Z_WINDOW_MAX) ? Z_WINDOW_BASE : (zIndexCounter + 1);
            return zIndexCounter;
        }
        let totalFlows = 0;
        let attacksDetected = 0;
        
        // Track attack types for analytics
        const attackTypeStats = {
            'DoS': 0,
            'Exploits': 0,
            'Fuzzers': 0,
            'Generic': 0,
            'Reconnaissance': 0,
            'Analysis': 0,
            'Backdoor': 0,
            'Shellcode': 0,
            'Worms': 0,
            'Normal': 0
        };
        
        // Track MITRE techniques seen
        const mitreStats = {};

        class Terminal {
            constructor(type, title, x, y, options = {}) {
                this.type = type;
                this.title = title;
                this.id = 'terminal-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                this.element = this.createTerminal(x, y);
                this.isDragging = false;
                this.isResizing = false;
                this.resizeDirection = '';
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.dragStartLeft = 0;
                this.dragStartTop = 0;
                this.resizeStart = { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0 };
                this.logs = [];
                this.isPaused = false;
                this.searchMatches = [];
                this.currentMatchIndex = -1;
                
                terminals.push(this);
                this.attachEventListeners();
                this.createTaskbarItem();

                if (options.activate) {
                    this.activate();
                }
            }

            activate() {
                this.element.style.zIndex = nextWindowZ();
                activeTerminal = this;
                this.element.classList.add('active');
                terminals.forEach(t => {
                    if (t !== this) t.element.classList.remove('active');
                });
                this.updateTaskbar();
            }

            minimizeWindow() {
                // Prevent if already animating
                if (this.element.classList.contains('minimizing') || 
                    this.element.classList.contains('restoring')) {
                    return;
                }
                // Minimize with macOS genie effect
                this.element.classList.add('minimizing');
                setTimeout(() => {
                    this.element.classList.add('minimized');
                    this.element.classList.remove('minimizing');
                    this.element.style.visibility = 'hidden';
                    this.updateTaskbar();
                }, 300);
            }

            restoreFromMinimize() {
                // Prevent if already animating
                if (this.element.classList.contains('minimizing') || 
                    this.element.classList.contains('restoring')) {
                    return;
                }
                // Restore with macOS genie effect
                this.element.style.visibility = 'visible';
                this.element.classList.remove('minimized');
                this.element.classList.add('restoring');
                setTimeout(() => {
                    this.element.classList.remove('restoring');
                    this.activate();
                }, 300);
            }

            createTerminal(x, y) {
                const terminal = document.createElement('div');
                terminal.className = 'terminal-window';
                terminal.id = this.id;
                terminal.style.left = x + 'px';
                terminal.style.top = y + 'px';
                terminal.style.width = '600px';
                terminal.style.height = '450px';
                
                // Add data-vm attribute for VM-specific styling
                if (this.type === 'vm-attacker') {
                    terminal.setAttribute('data-vm', 'attacker');
                } else if (this.type === 'vm-victim') {
                    terminal.setAttribute('data-vm', 'victim');
                }

                const iconColor = this.type === 'attack' || this.type === 'vm-attacker' ? 'red' : 
                                this.type === 'processing' ? 'yellow' : 
                                this.type === 'vm-victim' ? 'green' : 'green';

                terminal.innerHTML = `
                    <div class="resize-handle top"></div>
                    <div class="resize-handle bottom"></div>
                    <div class="resize-handle left"></div>
                    <div class="resize-handle right"></div>
                    <div class="resize-handle top-left"></div>
                    <div class="resize-handle top-right"></div>
                    <div class="resize-handle bottom-left"></div>
                    <div class="resize-handle bottom-right"></div>
                    <div class="terminal-header">
                        <div class="terminal-controls">
                            <span class="terminal-btn close"></span>
                            <span class="terminal-btn minimize"></span>
                            <span class="terminal-btn maximize"></span>
                        </div>
                        <div class="terminal-title">
                            <span class="terminal-icon ${iconColor}"></span>
                            ${this.title}
                        </div>
                        <div class="terminal-actions">
                            <button class="terminal-action-btn" title="Search (Ctrl+F)" data-action="search"><i class="fas fa-search"></i></button>
                            <button class="terminal-action-btn" title="Export Logs" data-action="export">💾</button>
                            <button class="terminal-action-btn" title="Pause/Resume" data-action="pause">⏸️</button>
                        </div>
                    </div>
                    <div class="terminal-search" id="search-${this.id}">
                        <input type="text" placeholder="Search..." class="terminal-search-input" />
                        <span class="terminal-search-count">0/0</span>
                        <div class="terminal-search-controls">
                            <button class="terminal-search-btn" data-dir="prev">▲</button>
                            <button class="terminal-search-btn" data-dir="next">▼</button>
                            <button class="terminal-search-btn" data-action="close">✕</button>
                        </div>
                    </div>
                    <div class="terminal-content"></div>
                    <div class="scroll-indicator" title="Scroll to bottom">↓ New content</div>
                `;

                document.getElementById('workspace').appendChild(terminal);
                
                // Setup scroll indicator
                const content = terminal.querySelector('.terminal-content');
                const scrollInd = terminal.querySelector('.scroll-indicator');
                content.addEventListener('scroll', () => this.updateScrollIndicator());
                scrollInd.addEventListener('click', () => {
                    content.scrollTop = content.scrollHeight;
                });
                
                return terminal;
            }
            
            updateScrollIndicator() {
                const content = this.element.querySelector('.terminal-content');
                const scrollInd = this.element.querySelector('.scroll-indicator');
                if (!content || !scrollInd) return;
                
                const isScrolledUp = content.scrollTop < content.scrollHeight - content.clientHeight - 50;
                scrollInd.classList.toggle('visible', isScrolledUp);
            }

            createTaskbarItem() {
                const taskbarItems = document.getElementById('taskbar-items');
                const taskbarItem = document.createElement('div');
                taskbarItem.className = 'taskbar-item';
                taskbarItem.id = 'taskbar-' + this.id;
                
                const iconColor = this.type === 'attack' || this.type === 'vm-attacker' ? 'red' : 
                                this.type === 'processing' ? 'yellow' : 
                                this.type === 'vm-victim' ? 'green' : 'green';
                
                taskbarItem.innerHTML = `
                    <span class="terminal-icon ${iconColor}"></span>
                    <span>${this.title}</span>
                `;

                taskbarItem.addEventListener('click', () => {
                    // Prevent action if animation is in progress
                    if (this.element.classList.contains('minimizing') || 
                        this.element.classList.contains('restoring')) {
                        return;
                    }
                    
                    if (this.element.classList.contains('minimized')) {
                        // Restore from minimize - call handler directly instead of triggering click
                        this.restoreFromMinimize();
                    } else if (this.element.classList.contains('active')) {
                        // If already active, minimize it
                        this.minimizeWindow();
                    } else {
                        // Bring to front
                        this.activate();
                    }
                });

                taskbarItems.appendChild(taskbarItem);
            }

            updateTaskbar() {
                terminals.forEach(t => {
                    const taskbarItem = document.getElementById('taskbar-' + t.id);
                    if (taskbarItem) {
                        if (t.element.classList.contains('active') && !t.element.classList.contains('minimized')) {
                            taskbarItem.classList.add('active');
                        } else {
                            taskbarItem.classList.remove('active');
                        }
                    }
                });
            }

            attachEventListeners() {
                const header = this.element.querySelector('.terminal-header');
                const closeBtn = this.element.querySelector('.terminal-btn.close');
                const minimizeBtn = this.element.querySelector('.terminal-btn.minimize');
                const maximizeBtn = this.element.querySelector('.terminal-btn.maximize');

                // Dragging
                header.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('terminal-btn')) return;
                    if (this.element.classList.contains('maximized')) return;
                    
                    // Bring window to front immediately
                    this.activate();
                    
                    // Store the exact mouse position relative to the window's current position
                    const currentLeft = parseInt(this.element.style.left) || 0;
                    const currentTop = parseInt(this.element.style.top) || 0;
                    
                    this.dragStartX = e.clientX;
                    this.dragStartY = e.clientY;
                    this.dragStartLeft = currentLeft;
                    this.dragStartTop = currentTop;
                    
                    this.isDragging = true;
                    this.element.classList.add('dragging');
                    
                    e.preventDefault();
                    e.stopPropagation();
                });

                // Resizing
                const resizeHandles = this.element.querySelectorAll('.resize-handle');
                resizeHandles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        if (this.element.classList.contains('maximized')) return;
                        
                        e.stopPropagation();
                        this.isResizing = true;
                        this.resizeDirection = handle.className.replace('resize-handle ', '');
                        this.element.classList.add('resizing');
                        
                        this.activate();

                        const rect = this.element.getBoundingClientRect();
                        this.resizeStart = {
                            x: e.clientX,
                            y: e.clientY,
                            width: rect.width,
                            height: rect.height,
                            left: rect.left,
                            top: rect.top
                        };
                    });
                });

                closeBtn.addEventListener('click', () => {
                    this.element.classList.add('closing');
                    const taskbarItem = document.getElementById('taskbar-' + this.id);
                    if (taskbarItem) {
                        taskbarItem.style.opacity = '0';
                        taskbarItem.style.transform = 'scale(0.8)';
                    }
                    setTimeout(() => {
                        this.element.remove();
                        if (taskbarItem) taskbarItem.remove();
                        const idx = terminals.indexOf(this);
                        if (idx > -1) terminals.splice(idx, 1);
                    }, 200);
                });

                minimizeBtn.addEventListener('click', () => {
                    // Prevent action if animation is in progress
                    if (this.element.classList.contains('minimizing') || 
                        this.element.classList.contains('restoring')) {
                        return;
                    }
                    
                    if (this.element.classList.contains('minimized')) {
                        this.restoreFromMinimize();
                    } else {
                        this.minimizeWindow();
                    }
                });

                // Hover on maximize button shows snap layout (Windows 11 style)
                let snapHoverTimeout = null;
                maximizeBtn.addEventListener('mouseenter', () => {
                    snapHoverTimeout = setTimeout(() => {
                        if (typeof showSnapOverlay === 'function') {
                            showSnapOverlay(this);
                        }
                    }, 400);
                });
                maximizeBtn.addEventListener('mouseleave', () => {
                    if (snapHoverTimeout) clearTimeout(snapHoverTimeout);
                });

                maximizeBtn.addEventListener('click', () => {
                    if (snapHoverTimeout) clearTimeout(snapHoverTimeout);
                    if (this.element.classList.contains('maximized')) {
                        // Restore with smooth animation
                        this.element.classList.add('maximizing');
                        this.element.classList.remove('maximized');
                        this.element.style.left = this.preMaximize.left;
                        this.element.style.top = this.preMaximize.top;
                        this.element.style.width = this.preMaximize.width;
                        this.element.style.height = this.preMaximize.height;
                        this.element.style.zIndex = ''; // Reset z-index
                        setTimeout(() => this.element.classList.remove('maximizing'), 300);
                    } else {
                        // Maximize with smooth animation - bring to front first
                        this.activate(); // Bring to front
                        this.preMaximize = {
                            left: this.element.style.left,
                            top: this.element.style.top,
                            width: this.element.style.width,
                            height: this.element.style.height
                        };
                        this.element.classList.add('maximizing');
                        this.element.classList.add('maximized');
                        // Set highest z-index for maximized window
                        this.element.style.zIndex = '9999';
                        setTimeout(() => this.element.classList.remove('maximizing'), 300);
                    }
                });

                // Double click to maximize/restore
                header.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('terminal-btn')) return;
                    maximizeBtn.click();
                });

                // Click anywhere on terminal to bring to front
                this.element.addEventListener('mousedown', () => {
                    if (!this.element.classList.contains('active')) {
                        this.activate();
                    }
                });

                // Context menu and copy/paste functionality
                const content = this.element.querySelector('.terminal-content');
                
                // Right-click context menu
                content.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showContextMenu(e.clientX, e.clientY, this);
                });

                // Keyboard shortcuts
                content.addEventListener('keydown', (e) => {
                    // Ctrl+C or Cmd+C - Copy
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        copySelectedText(content);
                    }
                    
                    // Ctrl+A or Cmd+A - Select All
                    if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                        e.preventDefault();
                        selectAllText(content);
                    }
                });

                // Make content focusable
                content.setAttribute('tabindex', '0');

                // Terminal action buttons
                const actionBtns = this.element.querySelectorAll('.terminal-action-btn');
                const searchBar = this.element.querySelector('.terminal-search');
                const searchInput = searchBar.querySelector('.terminal-search-input');
                
                actionBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = btn.dataset.action;
                        
                        if (action === 'search') {
                            searchBar.classList.toggle('active');
                            if (searchBar.classList.contains('active')) {
                                searchInput.focus();
                            }
                        } else if (action === 'export') {
                            this.exportLogs();
                        } else if (action === 'pause') {
                            this.togglePause(btn);
                        }
                    });
                });

                // Search functionality
                let searchMatches = [];
                let currentMatchIndex = -1;

                searchInput.addEventListener('input', () => {
                    this.performSearch(searchInput.value);
                });

                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.navigateSearch('prev');
                        } else {
                            this.navigateSearch('next');
                        }
                    } else if (e.key === 'Escape') {
                        searchBar.classList.remove('active');
                    }
                });

                // Search control buttons
                searchBar.querySelectorAll('.terminal-search-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (btn.dataset.dir) {
                            this.navigateSearch(btn.dataset.dir);
                        } else if (btn.dataset.action === 'close') {
                            searchBar.classList.remove('active');
                            this.clearSearch();
                        }
                    });
                });

                // Ctrl+F to open search
                content.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                        e.preventDefault();
                        searchBar.classList.add('active');
                        searchInput.focus();
                    }
                });

                // Store search state
                this.searchMatches = [];
                this.currentMatchIndex = -1;
            }

            performSearch(query) {
                const content = this.element.querySelector('.terminal-content');
                const searchBar = this.element.querySelector('.terminal-search');
                const countSpan = searchBar.querySelector('.terminal-search-count');
                
                // Clear previous highlights
                this.clearSearch();
                
                if (!query) {
                    countSpan.textContent = '0/0';
                    return;
                }
                
                // Get all text nodes
                const walker = document.createTreeWalker(
                    content,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                this.searchMatches = [];
                const nodes = [];
                
                while (walker.nextNode()) {
                    nodes.push(walker.currentNode);
                }
                
                // Find and highlight matches
                nodes.forEach(node => {
                    const text = node.textContent;
                    const regex = new RegExp(query, 'gi');
                    let match;
                    
                    while ((match = regex.exec(text)) !== null) {
                        this.searchMatches.push({ node, start: match.index, length: query.length });
                    }
                });
                
                // Apply highlights
                this.searchMatches.forEach((match, index) => {
                    const node = match.node;
                    const parent = node.parentNode;
                    const text = node.textContent;
                    
                    const before = text.substring(0, match.start);
                    const highlighted = text.substring(match.start, match.start + match.length);
                    const after = text.substring(match.start + match.length);
                    
                    const span = document.createElement('span');
                    span.className = 'highlight-search';
                    span.textContent = highlighted;
                    span.dataset.searchIndex = index;
                    
                    const fragment = document.createDocumentFragment();
                    if (before) fragment.appendChild(document.createTextNode(before));
                    fragment.appendChild(span);
                    if (after) fragment.appendChild(document.createTextNode(after));
                    
                    parent.replaceChild(fragment, node);
                });
                
                // Update count
                countSpan.textContent = this.searchMatches.length > 0 ? `1/${this.searchMatches.length}` : '0/0';
                
                // Highlight first match
                if (this.searchMatches.length > 0) {
                    this.currentMatchIndex = 0;
                    this.highlightCurrentMatch();
                }
            }

            navigateSearch(direction) {
                if (this.searchMatches.length === 0) return;
                
                if (direction === 'next') {
                    this.currentMatchIndex = (this.currentMatchIndex + 1) % this.searchMatches.length;
                } else {
                    this.currentMatchIndex = (this.currentMatchIndex - 1 + this.searchMatches.length) % this.searchMatches.length;
                }
                
                this.highlightCurrentMatch();
            }

            highlightCurrentMatch() {
                const content = this.element.querySelector('.terminal-content');
                const searchBar = this.element.querySelector('.terminal-search');
                const countSpan = searchBar.querySelector('.terminal-search-count');
                
                // Remove current highlight
                content.querySelectorAll('.highlight-search.current').forEach(el => {
                    el.classList.remove('current');
                });
                
                // Add current highlight
                const currentSpan = content.querySelector(`[data-search-index="${this.currentMatchIndex}"]`);
                if (currentSpan) {
                    currentSpan.classList.add('current');
                    currentSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                // Update count
                countSpan.textContent = `${this.currentMatchIndex + 1}/${this.searchMatches.length}`;
            }

            clearSearch() {
                const content = this.element.querySelector('.terminal-content');
                content.querySelectorAll('.highlight-search').forEach(span => {
                    const text = span.textContent;
                    span.replaceWith(document.createTextNode(text));
                });
                this.searchMatches = [];
                this.currentMatchIndex = -1;
            }

            exportLogs() {
                const content = this.element.querySelector('.terminal-content');
                const logs = Array.from(content.querySelectorAll('.log-entry')).map(entry => {
                    return entry.textContent.trim();
                }).join('\n');
                
                const blob = new Blob([logs], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().getTime()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                showCopyNotification('Logs exported successfully!');
            }

            togglePause(btn) {
                this.isPaused = !this.isPaused;
                btn.textContent = this.isPaused ? '▶️' : '⏸️';
                btn.title = this.isPaused ? 'Resume' : 'Pause';
                
                showCopyNotification(this.isPaused ? 'Terminal paused' : 'Terminal resumed');
            }

            addLog(message, type = 'normal') {
                const content = this.element.querySelector('.terminal-content');
                const now = new Date();
                const timestamp = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                
                // For VM windows, don't show timestamp - just raw terminal output
                const isVmWindow = this.type === 'vm-attacker' || this.type === 'vm-victim';
                if (isVmWindow) {
                    logEntry.innerHTML = `<span class="log-message">${message}</span>`;
                } else {
                    // For Monitor and SOC windows, show timestamp
                    const typeLabel = type === 'normal' ? '' : `<span class="log-type">${type.toUpperCase()}</span>`;
                    logEntry.innerHTML = `
                        <span class="log-timestamp">[${timestamp}]</span>
                        ${typeLabel}
                        <span class="log-message">${message}</span>
                    `;
                }
                
                // Append at bottom and auto-scroll down
                content.appendChild(logEntry);
                content.scrollTop = content.scrollHeight;
                this.updateScrollIndicator();

                this.logs.push({ timestamp, type, message });
            }

            addProcessStep(step, title, detail) {
                const content = this.element.querySelector('.terminal-content');
                
                const stepElement = document.createElement('div');
                stepElement.className = 'process-step';
                stepElement.innerHTML = `
                    <div class="step-icon">${step}</div>
                    <div class="step-content">
                        <div class="step-title">${title}</div>
                        <div class="step-detail">${detail}</div>
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                    </div>
                `;
                
                content.appendChild(stepElement);
                content.scrollTop = content.scrollHeight;
            }
        }

        // Edge snap detection
        const snapPreview = document.getElementById('snap-preview');
        let pendingSnap = null;
        const EDGE_THRESHOLD = 20;
        
        function showSnapPreview(zone) {
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height, pad = 8;
            
            const zones = {
                'left': { x: rect.left + pad, y: rect.top + pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'right': { x: rect.left + w/2 + pad/2, y: rect.top + pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'top-left': { x: rect.left + pad, y: rect.top + pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'top-right': { x: rect.left + w/2 + pad/2, y: rect.top + pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-left': { x: rect.left + pad, y: rect.top + h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-right': { x: rect.left + w/2 + pad/2, y: rect.top + h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'maximize': { x: rect.left + pad, y: rect.top + pad, w: w - pad*2, h: h - pad*2 }
            };
            
            const z = zones[zone];
            if (z) {
                snapPreview.style.left = z.x + 'px';
                snapPreview.style.top = z.y + 'px';
                snapPreview.style.width = z.w + 'px';
                snapPreview.style.height = z.h + 'px';
                snapPreview.classList.add('visible');
                pendingSnap = zone;
            }
        }
        
        function hideSnapPreview() {
            snapPreview.classList.remove('visible');
            pendingSnap = null;
        }
        
        function applyEdgeSnap(terminal, zone) {
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height, pad = 8;
            
            terminal.element.classList.remove('maximized');
            terminal.element.style.zIndex = '';
            terminal.element.classList.add('snapping');
            
            const zones = {
                'left': { x: pad, y: pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'right': { x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'top-left': { x: pad, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'top-right': { x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-left': { x: pad, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-right': { x: w/2 + pad/2, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'maximize': { x: pad, y: pad, w: w - pad*2, h: h - pad*2 }
            };
            
            const z = zones[zone];
            if (z) {
                terminal.element.style.left = z.x + 'px';
                terminal.element.style.top = z.y + 'px';
                terminal.element.style.width = z.w + 'px';
                terminal.element.style.height = z.h + 'px';
            }
            
            setTimeout(() => terminal.element.classList.remove('snapping'), 300);
            
            // Auto-arrange other terminals to fill remaining space
            const otherTerminals = terminals.filter(t => 
                t !== terminal && 
                !t.element.classList.contains('minimized') &&
                !t.element.classList.contains('maximized')
            );
            
            if (otherTerminals.length > 0 && zone !== 'maximize') {
                // Determine complementary zones based on snapped zone
                const complementaryZones = getComplementaryZones(zone, w, h, pad, otherTerminals.length);
                
                otherTerminals.forEach((t, i) => {
                    t.element.classList.add('snapping');
                    t.element.classList.remove('maximized');
                    t.element.style.zIndex = '';
                    
                    if (i < complementaryZones.length) {
                        const cz = complementaryZones[i];
                        t.element.style.left = cz.x + 'px';
                        t.element.style.top = cz.y + 'px';
                        t.element.style.width = cz.w + 'px';
                        t.element.style.height = cz.h + 'px';
                    }
                    
                    setTimeout(() => t.element.classList.remove('snapping'), 300);
                });
            }
        }
        
        // Get complementary zones for other terminals
        function getComplementaryZones(snappedZone, w, h, pad, terminalCount) {
            const zones = [];
            
            if (snappedZone === 'left') {
                // Stack terminals vertically on right side
                const cellH = (h - pad * (terminalCount + 1)) / terminalCount;
                for (let i = 0; i < terminalCount; i++) {
                    zones.push({ 
                        x: w/2 + pad/2, 
                        y: pad + i * (cellH + pad), 
                        w: w/2 - pad*1.5, 
                        h: cellH 
                    });
                }
            } else if (snappedZone === 'right') {
                // Stac top-linals vertically on left side
                const cellH = (h - pad * (terminalCount + 1)) / terminalCount;
                for (let i = 0; i < terminalCount; i++) {
                    zones.push({ 
                        x: pad, 
                        y: pad + i * (cellH + pad), 
                        w: w/2 - pad*1.5, 
                        h: cellH 
                    });
                }
            } else if (snappedZone === 'top-left') {
                // Fill remaining quadrants
                zones.push({ x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: pad, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: w/2 + pad/2, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
            } else if (snappedZone === 'top-right') {
                zones.push({ x: pad, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: pad, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: w/2 + pad/2, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
            } else if (snappedZone === 'bottom-left') {
                zones.push({ x: pad, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: w/2 + pad/2, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
            } else if (snappedZone === 'bottom-right') {
                zones.push({ x: pad, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
                zones.push({ x: pad, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 });
            }
            
            return zones;
        }

        // Mouse move handler
        document.addEventListener('mousemove', (e) => {
            if (activeTerminal) {
                if (activeTerminal.isDragging) {
                    // Calculate how much the mouse has moved since drag started
                    document.body.classList.add('dragging');
                    
                    const deltaX = e.clientX - activeTerminal.dragStartX;
                    const deltaY = e.clientY - activeTerminal.dragStartY;
                    
                    // Apply that movement to the original position
                    const newX = activeTerminal.dragStartLeft + deltaX;
                    const newY = activeTerminal.dragStartTop + deltaY;
                    
                    activeTerminal.element.style.left = newX + 'px';
                    activeTerminal.element.style.top = newY + 'px';
                    
                    // Windows 11 edge snap detection
                    const ws = document.getElementById('workspace');
                    const wsRect = ws.getBoundingClientRect();
                    const mouseX = e.clientX - wsRect.left;
                    const mouseY = e.clientY - wsRect.top;
                    
                    // Check edges
                    const atLeft = mouseX < EDGE_THRESHOLD;
                    const atRight = mouseX > wsRect.width - EDGE_THRESHOLD;
                    const atTop = mouseY < EDGE_THRESHOLD;
                    const atBottom = mouseY > wsRect.height - EDGE_THRESHOLD;
                    
                    if (atTop && atLeft) {
                        showSnapPreview('top-left');
                    } else if (atTop && atRight) {
                        showSnapPreview('top-right');
                    } else if (atBottom && atLeft) {
                        showSnapPreview('bottom-left');
                    } else if (atBottom && atRight) {
                        showSnapPreview('bottom-right');
                    } else if (atLeft) {
                        showSnapPreview('left');
                    } else if (atRight) {
                        showSnapPreview('right');
                    } else if (atTop) {
                        showSnapPreview('maximize');
                    } else {
                        hideSnapPreview();
                    }
                    
                    e.preventDefault();
                } else if (activeTerminal.isResizing) {
                    // Resizing
                    const direction = activeTerminal.resizeDirection;
                    
                    // Add appropriate cursor class
                    document.body.classList.remove('resizing-ns', 'resizing-ew', 'resizing-nwse', 'resizing-nesw');
                    if (direction === 'top' || direction === 'bottom') {
                        document.body.classList.add('resizing-ns');
                    } else if (direction === 'left' || direction === 'right') {
                        document.body.classList.add('resizing-ew');
                    } else if (direction === 'top-left' || direction === 'bottom-right') {
                        document.body.classList.add('resizing-nwse');
                    } else if (direction === 'top-right' || direction === 'bottom-left') {
                        document.body.classList.add('resizing-nesw');
                    }
                    
                    const dx = e.clientX - activeTerminal.resizeStart.x;
                    const dy = e.clientY - activeTerminal.resizeStart.y;
                    
                    const minWidth = 300;
                    const minHeight = 200;
                    const maxWidth = window.innerWidth - 50;
                    const maxHeight = window.innerHeight - 150;
                    
                    if (direction.includes('right')) {
                        const newWidth = Math.max(minWidth, Math.min(maxWidth, activeTerminal.resizeStart.width + dx));
                        activeTerminal.element.style.width = newWidth + 'px';
                    }
                    
                    if (direction.includes('left')) {
                        const newWidth = Math.max(minWidth, Math.min(maxWidth, activeTerminal.resizeStart.width - dx));
                        if (newWidth > minWidth) {
                            activeTerminal.element.style.width = newWidth + 'px';
                            activeTerminal.element.style.left = (activeTerminal.resizeStart.left + dx) + 'px';
                        }
                    }
                    
                    if (direction.includes('bottom')) {
                        const newHeight = Math.max(minHeight, Math.min(maxHeight, activeTerminal.resizeStart.height + dy));
                        activeTerminal.element.style.height = newHeight + 'px';
                    }
                    
                    if (direction.includes('top')) {
                        const newHeight = Math.max(minHeight, Math.min(maxHeight, activeTerminal.resizeStart.height - dy));
                        if (newHeight > minHeight) {
                            activeTerminal.element.style.height = newHeight + 'px';
                            activeTerminal.element.style.top = (activeTerminal.resizeStart.top + dy) + 'px';
                        }
                    }
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (activeTerminal) {
                // Apply edge snap if pending
                if (activeTerminal.isDragging && pendingSnap) {
                    applyEdgeSnap(activeTerminal, pendingSnap);
                    hideSnapPreview();
                }
                
                // Clear layout tracking if user manually moved/resized (and no snap applied)
                if ((activeTerminal.isDragging || activeTerminal.isResizing) && !pendingSnap) {
                    currentLayout = null;
                }
                activeTerminal.isDragging = false;
                activeTerminal.element.classList.remove('dragging');
                if (activeTerminal.isResizing) {
                    activeTerminal.isResizing = false;
                    activeTerminal.element.classList.remove('resizing');
                }
            }
            // Hide snap preview and remove cursor classes
            hideSnapPreview();
            document.body.classList.remove('dragging', 'resizing-ns', 'resizing-ew', 'resizing-nwse', 'resizing-nesw');
        });

        // Initialize default terminals
        // Starting with no terminals - user will create them via commands

        // Real-time only: no demo/simulated data is emitted.

        // Update statistics
        function updateStats() {
            document.getElementById('total-flows').textContent = totalFlows;
            document.getElementById('attacks-detected').textContent = attacksDetected;
            const detectionRate = totalFlows > 0 ? ((attacksDetected / totalFlows) * 100).toFixed(1) : 0;
            document.getElementById('detection-rate').textContent = detectionRate + '%';
        }

        // Show attack alert
        function showAttackAlert(message) {
            const alert = document.createElement('div');
            alert.className = 'alert-notification';
            alert.innerHTML = `
                <div class="alert-title"><i class="fas fa-exclamation-circle"></i> THREAT DETECTED</div>
                <div class="alert-details">${message}</div>
            `;
            
            document.body.appendChild(alert);
            
            setTimeout(() => {
                alert.style.animation = 'slideInRight 0.5s ease-out reverse';
                setTimeout(() => alert.remove(), 500);
            }, 5000);
        }

        // Sidebar toggle
        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('toggle-sidebar');
        
        // Track current layout for responsive adjustments
        let currentLayout = null;
        
        toggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            toggleBtn.textContent = sidebar.classList.contains('collapsed') ? '▶' : '◀';
            
            // Adjust terminals after sidebar toggle
            setTimeout(() => {
                adjustTerminalsToWorkspace();
            }, 300); // Wait for sidebar animation
        });
        
        // Responsive terminal adjustment
        function adjustTerminalsToWorkspace() {
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height;
            
            terminals.forEach(t => {
                // Skip minimized terminals
                if (t.element.classList.contains('minimized')) return;
                
                // Get current position
                const left = parseInt(t.element.style.left) || 0;
                const top = parseInt(t.element.style.top) || 0;
                const width = parseInt(t.element.style.width) || 400;
                const height = parseInt(t.element.style.height) || 300;
                
                // Ensure terminal stays within bounds
                let newLeft = left;
                let newTop = top;
                let newWidth = width;
                let newHeight = height;
                
                // Clamp width/height to workspace
                if (newWidth > w - 20) newWidth = w - 20;
                if (newHeight > h - 20) newHeight = h - 20;
                
                // Clamp position
                if (newLeft + newWidth > w) newLeft = Math.max(10, w - newWidth - 10);
                if (newTop + newHeight > h) newTop = Math.max(10, h - newHeight - 10);
                if (newLeft < 0) newLeft = 10;
                if (newTop < 0) newTop = 10;
                
                // Apply if changed
                if (newLeft !== left || newTop !== top || newWidth !== width || newHeight !== height) {
                    t.element.style.left = newLeft + 'px';
                    t.element.style.top = newTop + 'px';
                    t.element.style.width = newWidth + 'px';
                    t.element.style.height = newHeight + 'px';
                }
            });
            
            // Re-apply current layout if one was set
            if (currentLayout && terminals.filter(t => !t.element.classList.contains('minimized')).length > 1) {
                arrangeAllTerminals(currentLayout);
            }
        }
        
        // Window resize handler
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                adjustTerminalsToWorkspace();
            }, 150);
        });

        // Filter items
        document.querySelectorAll('.filter-item').forEach(item => {
            item.addEventListener('click', () => {
                // Only allow one active filter
                document.querySelectorAll('.filter-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                
                const filter = item.dataset.filter;
                console.log('Filter activated:', filter);
                // Here you would filter the logs based on the selected type
            });
        });

        // Quick actions
        document.getElementById('clear-logs')?.addEventListener('click', () => {
            terminals.forEach(t => {
                const content = t.element.querySelector('.terminal-content');
                if (content) content.innerHTML = '';
            });
            totalFlows = 0;
            attacksDetected = 0;
            // Reset attack type stats
            Object.keys(attackTypeStats).forEach(k => attackTypeStats[k] = 0);
            // Reset MITRE stats
            Object.keys(mitreStats).forEach(k => delete mitreStats[k]);
            updateStats();
            updateAnalyticsDashboard();
            updateThreatStats();
            // Clear backend alerts/state too.
            if (typeof sendSocCommand === 'function') {
                sendSocCommand('/clear');
            }
        });

        let isPaused = false;
        document.getElementById('pause-detection')?.addEventListener('click', function() {
            isPaused = !isPaused;
            this.querySelector('.quick-action-text').textContent = isPaused ? 'Resume Detection' : 'Pause Detection';
            this.querySelector('.quick-action-icon').textContent = isPaused ? '▶️' : '⏸️';
            // Pause UI rendering (backend continues running).
            terminals.forEach(t => { t.isPaused = isPaused; });
            if (typeof socUiPaused !== 'undefined') {
                socUiPaused = isPaused;
            }
        });

        document.getElementById('export-data')?.addEventListener('click', () => {
            if (typeof sendSocCommand === 'function') {
                sendSocCommand('/export json');
            }
        });

        document.getElementById('screenshot')?.addEventListener('click', () => {
            if (typeof addCommandLine === 'function') {
                addCommandLine('<span class="info">ℹ Use the browser menu to save/print the page for screenshots.</span>', 'info');
            }
        });

        // Navigation menu interactions with dashboard views
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                const navText = this.textContent.trim();
                
                document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                this.classList.add('active');
                
                // Hide all dashboard views and workspace
                document.querySelectorAll('.dashboard-view').forEach(view => {
                    view.classList.remove('active');
                });
                
                const workspace = document.getElementById('workspace');
                
                // Handle navigation
                switch(navText) {
                    case 'Dashboard':
                        // Show workspace with terminals
                        workspace.style.display = 'block';
                        break;
                    case 'Live Monitor':
                        workspace.style.display = 'none';
                        document.getElementById('view-live-monitor').classList.add('active');
                        updateLiveMonitorStats();
                        break;
                    case 'Analytics':
                        workspace.style.display = 'none';
                        document.getElementById('view-analytics').classList.add('active');
                        break;
                    case 'Threats':
                        workspace.style.display = 'none';
                        document.getElementById('view-threats').classList.add('active');
                        updateThreatStats();
                        break;
                    case 'Reports':
                        workspace.style.display = 'none';
                        document.getElementById('view-reports').classList.add('active');
                        break;
                }
            });
        });

        // Update live monitor stats with real-time data
        function updateLiveMonitorStats() {
            const flowsEl = document.getElementById('live-total-flows');
            const attacksEl = document.getElementById('live-attacks');
            const rateEl = document.getElementById('live-detection-rate');
            const wsStatusEl = document.getElementById('live-ws-status');
            
            if (flowsEl) flowsEl.textContent = totalFlows.toLocaleString();
            if (attacksEl) attacksEl.textContent = attacksDetected.toLocaleString();
            if (rateEl) {
                const rate = totalFlows > 0 ? ((attacksDetected / totalFlows) * 100).toFixed(1) : 0;
                rateEl.textContent = rate + '%';
            }
            if (wsStatusEl) {
                wsStatusEl.textContent = socConnected ? 'CONNECTED' : 'DISCONNECTED';
                wsStatusEl.style.color = socConnected ? '#333333' : '#000000';
            }
        }

        // Update threat stats
        function updateThreatStats() {
            const alertsEl = document.getElementById('threat-active-alerts');
            if (alertsEl) alertsEl.textContent = attacksDetected.toLocaleString();
            
            // Update MITRE techniques count
            const mitreCountEl = document.getElementById('threat-mitre-count');
            if (mitreCountEl) mitreCountEl.textContent = Object.keys(mitreStats).length;
            
            // Update MITRE list
            updateMitreList();
        }
        
        // Update analytics dashboard with real data
        function updateAnalyticsDashboard() {
            // Update attack type chart
            const chartContainer = document.getElementById('analytics-attack-chart');
            if (chartContainer) {
                const total = Object.values(attackTypeStats).reduce((a, b) => a + b, 0);
                if (total > 0) {
                    let html = '';
                    const sortedTypes = Object.entries(attackTypeStats)
                        .filter(([k, v]) => v > 0)
                        .sort((a, b) => b[1] - a[1]);
                    
                    for (const [type, count] of sortedTypes) {
                        const pct = ((count / total) * 100).toFixed(0);
                        html += `<div class="bar-item">
                            <div class="bar-label">${type}</div>
                            <div class="bar-track">
                                <div class="bar-fill" style="width: ${pct}%;">${count} (${pct}%)</div>
                            </div>
                        </div>`;
                    }
                    chartContainer.innerHTML = html;
                }
            }
            
            // Update total attacks in analytics
            const totalAttacksEl = document.getElementById('analytics-total-attacks');
            if (totalAttacksEl) totalAttacksEl.textContent = attacksDetected;
            
            // Update unique attack types
            const uniqueTypesEl = document.getElementById('analytics-unique-types');
            if (uniqueTypesEl) {
                const uniqueCount = Object.values(attackTypeStats).filter(v => v > 0).length;
                uniqueTypesEl.textContent = uniqueCount;
            }
            
            // Update threat stats too
            updateThreatStats();
        }
        
        // Update MITRE list dynamically
        function updateMitreList() {
            const listEl = document.getElementById('mitre-threat-list');
            if (!listEl) return;
            
            const sortedMitre = Object.entries(mitreStats)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            if (sortedMitre.length === 0) return;
            
            let html = '';
            for (const [techId, data] of sortedMitre) {
                const severity = data.count >= 5 ? 'critical' : data.count >= 3 ? 'high' : 'medium';
                const icon = severity === 'critical' ? '🔴' : severity === 'high' ? '🟠' : '🟡';
                html += `<li class="threat-item ${severity}">
                    <div class="threat-title">${icon} ${techId} - ${data.name || 'Unknown'}</div>
                    <div class="threat-details">Tactic: ${data.tactic || 'Unknown'} | Count: ${data.count}</div>
                </li>`;
            }
            listEl.innerHTML = html;
        }

        // Update stats periodically when on live monitor view
        setInterval(() => {
            const liveMonitor = document.getElementById('view-live-monitor');
            if (liveMonitor && liveMonitor.classList.contains('active')) {
                updateLiveMonitorStats();
            }
            const analyticsView = document.getElementById('view-analytics');
            if (analyticsView && analyticsView.classList.contains('active')) {
                updateAnalyticsDashboard();
            }
            const threatsView = document.getElementById('view-threats');
            if (threatsView && threatsView.classList.contains('active')) {
                updateThreatStats();
            }
        }, 2000);

        function setActiveNavByLabel(label) {
            const wanted = String(label || '').trim().toLowerCase();
            if (!wanted) return;
            const items = Array.from(document.querySelectorAll('.nav-item'));
            const target = items.find(i => String(i.textContent || '').trim().toLowerCase() === wanted);
            if (!target) return;
            items.forEach(i => i.classList.remove('active'));
            target.classList.add('active');
            // Trigger click to show the view
            target.click();
        }

        // Action buttons
        document.getElementById('settings-btn')?.addEventListener('click', () => {
            addCommandLine('<span class="info">ℹ Use /help to see available commands</span>', 'info');
        });

        document.getElementById('export-btn')?.addEventListener('click', () => {
            sendSocCommand('/export json');
        });

        // Context Menu and Copy/Paste System
        const contextMenu = document.getElementById('context-menu');
        let contextMenuTerminal = null;

        function showContextMenu(x, y, terminal) {
            contextMenuTerminal = terminal;
            const content = terminal.element.querySelector('.terminal-content');
            const selectedText = window.getSelection().toString();
            
            // Enable/disable copy based on selection
            const copyItem = document.getElementById('context-copy');
            if (selectedText) {
                copyItem.classList.remove('disabled');
            } else {
                copyItem.classList.add('disabled');
            }
            
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.classList.add('active');
        }

        function hideContextMenu() {
            contextMenu.classList.remove('active');
            contextMenuTerminal = null;
        }

        function copySelectedText(content) {
            const selectedText = window.getSelection().toString();
            if (selectedText) {
                navigator.clipboard.writeText(selectedText).then(() => {
                    showCopyNotification('Text copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            }
        }

        function selectAllText(content) {
            const range = document.createRange();
            range.selectNodeContents(content);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }

        function clearTerminal(terminal) {
            const content = terminal.element.querySelector('.terminal-content');
            content.innerHTML = '';
        }

        function showCopyNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.innerHTML = `<span><i class="fas fa-check"></i></span><span>${message}</span>`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideInRight 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // Context menu item handlers
        document.getElementById('context-copy').addEventListener('click', () => {
            if (contextMenuTerminal) {
                const content = contextMenuTerminal.element.querySelector('.terminal-content');
                copySelectedText(content);
            }
            hideContextMenu();
        });

        document.getElementById('context-paste').addEventListener('click', async () => {
            if (contextMenuTerminal) {
                try {
                    const text = await navigator.clipboard.readText();
                    showCopyNotification('Paste: ' + text.substring(0, 30) + (text.length > 30 ? '...' : ''));
                } catch (err) {
                    console.error('Failed to read clipboard:', err);
                }
            }
            hideContextMenu();
        });

        document.getElementById('context-select-all').addEventListener('click', () => {
            if (contextMenuTerminal) {
                const content = contextMenuTerminal.element.querySelector('.terminal-content');
                selectAllText(content);
            }
            hideContextMenu();
        });

        document.getElementById('context-search').addEventListener('click', () => {
            if (contextMenuTerminal) {
                const searchBar = contextMenuTerminal.element.querySelector('.terminal-search');
                searchBar.classList.add('active');
                searchBar.querySelector('.terminal-search-input').focus();
            }
            hideContextMenu();
        });

        document.getElementById('context-clear').addEventListener('click', () => {
            if (contextMenuTerminal) {
                clearTerminal(contextMenuTerminal);
            }
            hideContextMenu();
        });

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });

        // Hide context menu on scroll
        document.addEventListener('scroll', hideContextMenu, true);

        // Update taskbar clock
        function updateClock() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('taskbar-time').textContent = `${hours}:${minutes}:${seconds}`;
        }
        
        updateClock();
        setInterval(updateClock, 1000);

        // ==============================
        // SOC Backend Wiring (WS + REST)
        // ==============================
        // Layout/UI is unchanged. This only connects commands and live events.
        const DEFAULT_BACKEND_HOST = '127.0.0.1:8765';
        const pageIsHttp = (location.protocol === 'http:' || location.protocol === 'https:');
        const backendHost = pageIsHttp ? location.host : DEFAULT_BACKEND_HOST;
        const restOrigin = pageIsHttp ? location.origin : `http://${DEFAULT_BACKEND_HOST}`;
        const wsProto = (location.protocol === 'https:') ? 'wss:' : 'ws:';

        const SOC_BACKEND_WS_URL = `${wsProto}//${backendHost}/ws`;
        // Only forward SOC execution commands to backend.
        // Keep /help local so it can document UI-only commands like /open and /viz.
        const SOC_COMMANDS = new Set([
            '/status', '/zeek', '/zeek-pcap', '/replay', '/attack', '/attacks', '/clear', '/export',
            '/pcaps', '/ids', '/stats', '/note', '/tag', '/state', '/simulate', '/attack-real'
        ]);

        let socWs = null;
        let socConnected = false;
        let socUiPaused = false;

        function escapeHtml(s) {
            return String(s)
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;');
        }

        // Track terminals being created to prevent race conditions
        const terminalCreationLock = new Set();

        function getOrCreateTerminal(type, title) {
            // Check if terminal already exists
            let t = terminals.find(x => x.type === type);
            if (t) {
                // Don't re-animate existing terminal
                t.element.classList.add('no-animation');
                setTimeout(() => t.element.classList.remove('no-animation'), 50);
                return t;
            }
            
            // Check if we're already creating this terminal type
            if (terminalCreationLock.has(type)) {
                // Wait a bit and try to find it again
                return terminals.find(x => x.type === type) || null;
            }
            
            // Lock and create
            terminalCreationLock.add(type);
            try {
                // Double-check after acquiring lock
                t = terminals.find(x => x.type === type);
                if (t) {
                    t.element.classList.add('no-animation');
                    setTimeout(() => t.element.classList.remove('no-animation'), 50);
                    return t;
                }
                
                const x = 100 + Math.random() * 200;
                const y = 100 + Math.random() * 150;
                // Don't steal focus for backend-created terminals.
                t = new Terminal(type, title, x, y, { activate: false });
                return t;
            } finally {
                // Release lock after a short delay to ensure terminal is registered
                setTimeout(() => terminalCreationLock.delete(type), 100);
            }
        }

        function closeTerminalByType(type) {
            const t = terminals.find(x => x.type === type);
            if (!t) return;
            try {
                t.element.remove();
                const taskbarItem = document.getElementById('taskbar-' + t.id);
                if (taskbarItem) taskbarItem.remove();
            } catch {}
            const idx = terminals.indexOf(t);
            if (idx > -1) terminals.splice(idx, 1);
        }

        function closeSocStatusTerminal() {
            closeTerminalByType('status');
        }

        const liveIndicatorDot = document.querySelector('.status-indicator');
        function setLiveIndicator(isOnline) {
            if (!liveIndicatorDot) return;
            liveIndicatorDot.classList.toggle('online', !!isOnline);
        }

        function handleSocMessage(msg) {
            if (!msg || typeof msg !== 'object') return;

            // When paused, still show connection + command results.
            if (socUiPaused && msg.type !== 'system_status' && msg.type !== 'command_output') return;

            if (msg.type === 'system_status') {
                setLiveIndicator(true);
                // Only update internal state, don't spam command output
                // Status is shown in the header stats bar instead
                return;
            }

            if (msg.type === 'command_output') {
                const stream = String(msg.stream || 'backend');
                const level = String(msg.level || 'stdout');
                const line = String(msg.line || '');

                if (stream === 'command') {
                    const isErr = level.toLowerCase() === 'stderr';
                    addCommandLine(
                        isErr
                            ? `<span class="error"><i class="fas fa-times"></i></span> ${escapeHtml(line)}`
                            : `<span class="success"><i class="fas fa-check"></i></span> ${escapeHtml(line)}`,
                        isErr ? 'error' : 'success'
                    );
                } else if (stream === 'zeek' || stream === 'replay' || stream === 'simulator') {
                    // Route zeek/replay/simulator output to a dedicated Process Output terminal
                    // Use getOrCreateTerminal to prevent duplicates
                    let term = getOrCreateTerminal('process', '<i class="fas fa-cog"></i> Process Output');
                    const isErr = level.toLowerCase() === 'stderr';
                    const logType = isErr ? 'warning' : 'normal';
                    const prefix = stream === 'simulator' ? 'SIM' : stream.toUpperCase();
                    term.addLog(`[${prefix}] ${line}`, logType);
                } else {
                    // Other streams go to command terminal
                    const isErr = level.toLowerCase() === 'stderr';
                    addCommandLine(
                        `${isErr ? '<span class=\"error\"><i class=\"fas fa-times\"></i></span>' : '<span class=\"success\"><i class=\"fas fa-check\"></i></span>'} [${escapeHtml(stream)}] ${escapeHtml(line)}`,
                        isErr ? 'error' : 'success'
                    );
                }
                return;
            }

            if (msg.type === 'stats_update') {
                const s = msg.stats || {};
                if (typeof s.total_flows === 'number') totalFlows = s.total_flows;
                if (typeof s.total_alerts === 'number') attacksDetected = s.total_alerts;
                updateStats();
                // Don't spam Monitor with stats - only show attacks
                return;
            }

            // VM Setup - Create EXACTLY 3 windows: Attacker | SOC | Victim
            if (msg.type === 'vm_setup') {
                // STRICT: Close all other windows first
                closeAllExtraWindows();
                
                const attackType = msg.attack_type || 'unknown';
                const attacker = msg.attacker || {};
                const victim = msg.victim || {};
                const ts = new Date().toLocaleTimeString();
                
                // Get workspace dimensions for 3-column layout
                const ws = document.getElementById('workspace');
                const rect = ws.getBoundingClientRect();
                const w = rect.width, h = rect.height, pad = 10;
                
                const colW = (w - pad * 4) / 3;
                const termH = h - pad * 2;
                
                // === WINDOW 1: ATTACKER (LEFT) ===
                let attackerTerm = terminals.find(t => t.type === 'vm-attacker');
                const attackerExists = !!attackerTerm;
                if (!attackerTerm) {
                    attackerTerm = new Terminal('vm-attacker', 'Attacker VM (Kali)', pad, pad, { activate: false });
                } else {
                    // Disable animation for existing terminal
                    attackerTerm.element.classList.add('no-animation');
                }
                attackerTerm.element.style.left = pad + 'px';
                attackerTerm.element.style.top = pad + 'px';
                attackerTerm.element.style.width = colW + 'px';
                attackerTerm.element.style.height = termH + 'px';
                attackerTerm.element.style.zIndex = nextWindowZ();
                if (attackerExists) {
                    setTimeout(() => attackerTerm.element.classList.remove('no-animation'), 50);
                }
                
                const atkContent = attackerTerm.element.querySelector('.terminal-content');
                atkContent.innerHTML = `
                    <div style="color:#4ade80;margin-bottom:8px;">┌──(root㉿kali)-[~]</div>
                    <div style="color:#4ade80;">└─# <span style="color:#fff;">echo "Starting ${attackType.toUpperCase()} attack..."</span></div>
                    <div style="color:#94a3b8;margin:4px 0;">Starting ${attackType.toUpperCase()} attack...</div>
                    <div style="color:#4ade80;margin-top:8px;">┌──(root㉿kali)-[~]</div>
                    <div style="color:#4ade80;">└─# <span style="color:#fff;">export TARGET=${victim.ip}</span></div>
                    <div style="color:#4ade80;margin-top:8px;">┌──(root㉿kali)-[~]</div>
                    <div style="color:#4ade80;">└─# <span style="color:#f87171;font-weight:bold;">_</span></div>
                `;
                
                // === WINDOW 2: NETWORK MONITOR / SOC DETECTION (CENTER) ===
                // Use monitor terminal for attack detection display
                let monitorTerm = terminals.find(t => t.type === 'monitor');
                const monitorExists = !!monitorTerm;
                if (!monitorTerm) {
                    monitorTerm = new Terminal('monitor', 'Network Monitor - Attack Detection', pad * 2 + colW, pad, { activate: true });
                } else {
                    monitorTerm.element.classList.add('no-animation');
                    monitorTerm.activate();
                }
                monitorTerm.element.style.left = (pad * 2 + colW) + 'px';
                monitorTerm.element.style.top = pad + 'px';
                monitorTerm.element.style.width = colW + 'px';
                monitorTerm.element.style.height = termH + 'px';
                monitorTerm.element.style.zIndex = nextWindowZ();
                if (monitorExists) {
                    setTimeout(() => monitorTerm.element.classList.remove('no-animation'), 50);
                }
                
                // Clear and initialize monitor content
                const monContent = monitorTerm.element.querySelector('.terminal-content');
                monContent.innerHTML = '';
                monitorTerm.addLog(`ML Detection Engine Active`, 'normal');
                monitorTerm.addLog(`Source: ${attacker.ip} | Target: ${victim.ip}`, 'normal');
                monitorTerm.addLog(`─────────────────────────────────`, 'normal');
                
                // === WINDOW 3: VICTIM (RIGHT) ===
                let victimTerm = terminals.find(t => t.type === 'vm-victim');
                const victimExists = !!victimTerm;
                if (!victimTerm) {
                    victimTerm = new Terminal('vm-victim', 'Victim VM (Ubuntu)', pad * 3 + colW * 2, pad, { activate: false });
                } else {
                    victimTerm.element.classList.add('no-animation');
                }
                victimTerm.element.style.left = (pad * 3 + colW * 2) + 'px';
                victimTerm.element.style.top = pad + 'px';
                victimTerm.element.style.width = colW + 'px';
                victimTerm.element.style.height = termH + 'px';
                victimTerm.element.style.zIndex = nextWindowZ();
                if (victimExists) {
                    setTimeout(() => victimTerm.element.classList.remove('no-animation'), 50);
                }
                
                const vicContent = victimTerm.element.querySelector('.terminal-content');
                vicContent.innerHTML = `
                    <div style="color:#4ade80;">user@ubuntu-server:<span style="color:#60a5fa;">~</span>$ <span style="color:#fff;">tail -f /var/log/syslog</span></div>
                    <div style="color:#94a3b8;margin:4px 0;">${ts} ubuntu-server kernel: [${Math.floor(Math.random()*10000)}.${Math.floor(Math.random()*1000)}] IPv4: ${victim.ip}</div>
                    <div style="color:#94a3b8;">${ts} ubuntu-server systemd[1]: Started Session monitoring.</div>
                    <div style="color:#fbbf24;margin-top:8px;">${ts} ubuntu-server kernel: [WARN] Incoming connection from ${attacker.ip}</div>
                `;
                
                return;
            }

            // VM Stream - Real-time data (realistic terminal output)
            if (msg.type === 'vm_stream') {
                const vm = msg.vm || 'attacker';
                const stream = msg.stream || 'log';
                const content = msg.content || '';
                const cleanContent = escapeHtml(content.replace(/^root@kali:~# /, ''));
                
                const termType = vm === 'attacker' ? 'vm-attacker' : 'vm-victim';
                let term = terminals.find(t => t.type === termType);
                
                if (term) {
                    const termContent = term.element.querySelector('.terminal-content');
                    let html = '';
                    
                    if (vm === 'attacker') {
                        if (stream === 'command') {
                            html = `<div style="color:#4ade80;margin-top:6px;">┌──(root㉿kali)-[~]</div>
                                    <div style="color:#4ade80;">└─# <span style="color:#fff;">${cleanContent}</span></div>`;
                        } else if (stream === 'packet') {
                            html = `<div style="color:#f87171;font-size:11px;margin:2px 0;">  → ${cleanContent}</div>`;
                        } else {
                            html = `<div style="color:#94a3b8;font-size:11px;">${cleanContent}</div>`;
                        }
                    } else {
                        const ts = new Date().toLocaleTimeString();
                        if (stream === 'log') {
                            html = `<div style="color:#f87171;font-size:11px;">${ts} ${cleanContent}</div>`;
                        } else {
                            html = `<div style="color:#94a3b8;font-size:11px;">${cleanContent}</div>`;
                        }
                    }
                    
                    term.addLog(html, 'normal');
                }
                return;
            }

            if (msg.type === 'flow') {
                totalFlows++;
                updateStats();
                // Don't show every flow in Monitor - only show attacks
                return;
            }

            if (msg.type === 'attack_alert') {
                const alertId = attacksDetected; // 0-indexed alert ID for backend commands
                attacksDetected++;
                updateStats();

                const attack = String(msg.attack || 'malicious_unclassified');
                const conf = Number(msg.confidence || 0);
                const src = String(msg.src || '');
                const dst = String(msg.dst || '');
                const evidence = Array.isArray(msg.evidence) ? msg.evidence.map(String) : [];
                
                // Track attack type for analytics
                const attackKey = attack.charAt(0).toUpperCase() + attack.slice(1).toLowerCase();
                if (attackTypeStats.hasOwnProperty(attackKey)) {
                    attackTypeStats[attackKey]++;
                } else {
                    attackTypeStats[attackKey] = 1;
                }
                
                // Extract MITRE and explainability
                const mitre = msg.mitre || {};
                const xai = msg.explainability || {};
                
                // Track MITRE technique
                if (mitre.technique_id) {
                    const mitreKey = mitre.technique_id;
                    if (!mitreStats[mitreKey]) {
                        mitreStats[mitreKey] = { count: 0, name: mitre.technique_name, tactic: mitre.tactic_name };
                    }
                    mitreStats[mitreKey].count++;
                }
                
                // Update analytics dashboard
                updateAnalyticsDashboard();
                const mitreStr = mitre.technique_id ? `${mitre.technique_id} (${mitre.tactic_name})` : '';
                const mitreTechName = mitre.technique_name || '';
                const xaiFeatures = Array.isArray(xai.top_features) ? xai.top_features : [];
                const xaiEvidence = Array.isArray(xai.zeek_evidence) ? xai.zeek_evidence : [];
                const xaiConfidence = Array.isArray(xai.confidence_factors) ? xai.confidence_factors : [];
                
                // Show attack in Network Monitor with clean formatting
                let monitorTerm = terminals.find(x => x.type === 'monitor');
                if (monitorTerm && !monitorTerm.isPaused) {
                    // Clean single-line format for each detection
                    const confPct = (conf * 100).toFixed(1);
                    const mitreTag = mitre.technique_id ? ` [${mitre.technique_id}]` : '';
                    monitorTerm.addLog(`${attack.toUpperCase()} (${confPct}%) ${src} → ${dst}${mitreTag}`, 'attack');
                }

                // Route to Attack Logs terminal - auto-create if not exists
                let attackTerm = terminals.find(t => t.type === 'attack');
                if (!attackTerm) {
                    const x = 500 + Math.random() * 100;
                    const y = 100 + Math.random() * 80;
                    attackTerm = new Terminal('attack', '<i class="fas fa-shield-alt"></i> Attack Detection', x, y, { activate: true });
                } else {
                    // Don't re-animate existing terminal
                    attackTerm.element.classList.add('no-animation');
                    setTimeout(() => attackTerm.element.classList.remove('no-animation'), 50);
                }
                
                // Format alert nicely
                const confPct = (conf * 100).toFixed(1);
                const mitreTag = mitre.technique_id ? `${mitre.technique_id}` : '';
                const alertMsg = `ALERT #${alertId} | ${attack.toUpperCase()} | ${confPct}% confidence
${src} → ${dst}${mitreTag ? '\nMITRE: ' + mitreTag + ' (' + (mitre.tactic_name || '') + ')' : ''}`;
                attackTerm.addLog(alertMsg, 'attack');

                // Also show in command terminal
                addCommandLine(
                    `<span class=\"error\"><i class=\"fas fa-times\"></i></span> ALERT #${alertId} ${escapeHtml(attack)} conf=${(conf * 100).toFixed(1)}% src=${escapeHtml(src)} dst=${escapeHtml(dst)}${mitreStr ? ' MITRE:' + escapeHtml(mitreStr) : ''}`,
                    'error'
                );
                // Popup removed - attacks shown in Monitor terminal
                return;
            }
        }

        function connectSocBackend() {
            try {
                socWs = new WebSocket(SOC_BACKEND_WS_URL);

                socWs.onopen = () => {
                    socConnected = true;
                    setLiveIndicator(true);
                    // Close processing terminal on connect
                    closeTerminalByType('processing');
                    addCommandLine(`<span class="success"><i class="fas fa-check"></i> Connected: ${SOC_BACKEND_WS_URL}</span>`, 'success');
                    
                    // Show server initialization in Network Monitor terminal
                    const monitorTerm = getOrCreateTerminal('monitor', 'Network Monitor');
                    if (monitorTerm) {
                        monitorTerm.addLog(`SOC Backend Connected`, 'normal');
                        monitorTerm.addLog(`WebSocket: ${SOC_BACKEND_WS_URL}`, 'normal');
                        monitorTerm.addLog(`Dataset: UNSW-NB15`, 'normal');
                        monitorTerm.addLog(`Features: 41 network features`, 'normal');
                        monitorTerm.addLog(`Model: Random Forest (Binary)`, 'normal');
                        monitorTerm.addLog(`Ready for attack detection`, 'normal');
                    }
                };

                socWs.onmessage = (ev) => {
                    let msg;
                    try { msg = JSON.parse(ev.data); } catch { return; }
                    handleSocMessage(msg);
                };

                socWs.onclose = () => {
                    const wasConnected = socConnected;
                    socConnected = false;
                    setLiveIndicator(false);
                    if (wasConnected) addCommandLine(`<span class="error"><i class="fas fa-times"></i> SOC backend disconnected</span>`, 'error');
                    setTimeout(connectSocBackend, 2000);
                };

                socWs.onerror = (err) => {
                    console.error('WebSocket error:', err);
                    socConnected = false;
                    setLiveIndicator(false);
                };
            } catch (e) {
                console.error('WebSocket connection failed:', e);
                socConnected = false;
                setLiveIndicator(false);
                setTimeout(connectSocBackend, 3000);
            }
        }

        function sendSocCommand(line) {
            const payload = JSON.stringify({ type: 'command', command: line });
            if (socWs && socConnected && socWs.readyState === WebSocket.OPEN) {
                socWs.send(payload);
                return;
            }

            addCommandLine(`<span class="error"><i class="fas fa-times"></i></span> SOC backend not reachable`, 'error');
        }

        // Alert lifecycle action helpers
        function alertAction(action, alertId, value) {
            const cmd = `/${action} ${alertId} ${value}`;
            sendSocCommand(cmd);
            addCommandLine(`<span class="info">→</span> ${escapeHtml(cmd)}`, 'info');
        }

        function promptAlertNote(alertId) {
            const note = prompt(`Add note to alert #${alertId}:`);
            if (note && note.trim()) {
                alertAction('note', alertId, note.trim());
            }
        }

        function promptAlertTag(alertId) {
            const tag = prompt(`Add tag to alert #${alertId} (e.g., critical, reviewed, escalated):`);
            if (tag && tag.trim()) {
                alertAction('tag', alertId, tag.trim().toLowerCase().replace(/\s+/g, '_'));
            }
        }

        connectSocBackend();

        // Command Terminal
        const commandInput = document.getElementById('command-input');
        const commandOutput = document.getElementById('command-output');
        const commandTerminal = document.getElementById('command-terminal');
        const commandToggle = document.getElementById('command-toggle');
        const commandResizeHandle = document.getElementById('command-resize-handle');
        let commandHistory = [];
        let historyIndex = -1;

        function setCommandTerminalHeight(px) {
            const clamped = Math.max(50, Math.min(px, Math.floor(window.innerHeight * 0.75)));
            document.documentElement.style.setProperty('--command-terminal-height', `${clamped}px`);
        }

        // Initial layout: command terminal = collapsed height
        let lastExpandedHeight = 300;
        setCommandTerminalHeight(50);

        // Toggle command terminal expansion
        commandToggle.addEventListener('click', () => {
            const expanded = commandTerminal.classList.toggle('expanded');
            if (expanded) {
                setCommandTerminalHeight(lastExpandedHeight);
                commandToggle.textContent = '▼';
                // Terminal-like behavior: prompt stays at bottom, history scrolls.
                requestAnimationFrame(() => {
                    commandOutput.scrollTop = commandOutput.scrollHeight;
                    commandInput.focus();
                });
            } else {
                setCommandTerminalHeight(50);
                commandToggle.textContent = '▲';
            }
        });

        // Drag-resize command terminal height
        (() => {
            if (!commandResizeHandle) return;
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;

            commandResizeHandle.addEventListener('mousedown', (e) => {
                // Ensure expanded when user starts resizing
                if (!commandTerminal.classList.contains('expanded')) {
                    commandTerminal.classList.add('expanded');
                    commandToggle.textContent = '▼';
                    setCommandTerminalHeight(lastExpandedHeight);
                }
                isResizing = true;
                startY = e.clientY;
                startHeight = parseInt(getComputedStyle(commandTerminal).height || '50', 10);
                document.body.classList.add('resizing-ns');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                // Dragging up increases height
                const dy = startY - e.clientY;
                const next = Math.max(120, startHeight + dy);
                setCommandTerminalHeight(next);
                lastExpandedHeight = Math.max(120, Math.min(next, Math.floor(window.innerHeight * 0.75)));
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                document.body.classList.remove('resizing-ns');
            });

            window.addEventListener('resize', () => {
                if (!commandTerminal.classList.contains('expanded')) return;
                setCommandTerminalHeight(lastExpandedHeight);
            });
        })();

        // Taskbar + button: open a new terminal
        document.getElementById('taskbar-add-terminal')?.addEventListener('click', () => {
            // Check if Network Monitor already exists
            let existingMonitor = terminals.find(t => t.type === 'monitor');
            if (existingMonitor) {
                existingMonitor.activate();
                return;
            }
            const x = 70 + Math.random() * 260;
            const y = 90 + Math.random() * 180;
            new Terminal('monitor', 'Network Monitor', x, y, { activate: true });
        });

        // Windows 11 Style Snap Layout System
        const snapOverlay = document.getElementById('snap-overlay');
        let snapTarget = null;
        let selectedSnapZone = null;

        function showSnapOverlay(terminal) {
            if (!terminal) return;
            snapTarget = terminal;
            snapOverlay.classList.add('active');
            // Clear previous selections
            document.querySelectorAll('.snap-layout-preview div').forEach(d => d.classList.remove('highlight'));
        }

        function hideSnapOverlay() {
            snapOverlay.classList.remove('active');
            snapTarget = null;
            selectedSnapZone = null;
        }

        function applySnapLayout(zone) {
            if (!snapTarget) return;
            
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height, pad = 8;
            
            snapTarget.element.classList.remove('maximized');
            
            const layouts = {
                'left': { x: pad, y: pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'right': { x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h - pad*2 },
                'left-third': { x: pad, y: pad, w: w/3 - pad*1.3, h: h - pad*2 },
                'center-third': { x: w/3 + pad/2, y: pad, w: w/3 - pad, h: h - pad*2 },
                'right-third': { x: w*2/3 + pad/2, y: pad, w: w/3 - pad*1.3, h: h - pad*2 },
                'top-left': { x: pad, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'top-right': { x: w/2 + pad/2, y: pad, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-left': { x: pad, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'bottom-right': { x: w/2 + pad/2, y: h/2 + pad/2, w: w/2 - pad*1.5, h: h/2 - pad*1.5 },
                'left-large': { x: pad, y: pad, w: w*2/3 - pad*1.5, h: h - pad*2 },
                'right-small': { x: w*2/3 + pad/2, y: pad, w: w/3 - pad*1.3, h: h - pad*2 },
                'full': { x: pad, y: pad, w: w - pad*2, h: h - pad*2 }
            };
            
            const layout = layouts[zone];
            if (layout) {
                // Add snapping animation
                snapTarget.element.classList.add('snapping');
                snapTarget.element.style.left = layout.x + 'px';
                snapTarget.element.style.top = layout.y + 'px';
                snapTarget.element.style.width = layout.w + 'px';
                snapTarget.element.style.height = layout.h + 'px';
                setTimeout(() => snapTarget?.element?.classList.remove('snapping'), 250);
            }
            
            hideSnapOverlay();
        }
        
        // Snap all visible terminals to a layout
        function snapAllTerminals(layoutType) {
            const visible = terminals.filter(t => !t.element.classList.contains('minimized'));
            if (visible.length === 0) return;
            
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height, pad = 8;
            
            visible.forEach((t, i) => {
                t.element.classList.remove('maximized');
                t.element.classList.add('snapping');
                
                if (layoutType === 'half' && visible.length >= 2) {
                    // First 2 terminals side by side
                    if (i === 0) {
                        t.element.style.left = pad + 'px';
                        t.element.style.width = (w/2 - pad*1.5) + 'px';
                    } else if (i === 1) {
                        t.element.style.left = (w/2 + pad/2) + 'px';
                        t.element.style.width = (w/2 - pad*1.5) + 'px';
                    }
                    t.element.style.top = pad + 'px';
                    t.element.style.height = (h - pad*2) + 'px';
                } else if (layoutType === 'quarters' && visible.length >= 4) {
                    // 4 terminals in quadrants
                    const positions = [
                        { x: pad, y: pad },
                        { x: w/2 + pad/2, y: pad },
                        { x: pad, y: h/2 + pad/2 },
                        { x: w/2 + pad/2, y: h/2 + pad/2 }
                    ];
                    if (i < 4) {
                        t.element.style.left = positions[i].x + 'px';
                        t.element.style.top = positions[i].y + 'px';
                        t.element.style.width = (w/2 - pad*1.5) + 'px';
                        t.element.style.height = (h/2 - pad*1.5) + 'px';
                    }
                } else if (layoutType === 'thirds' && visible.length >= 3) {
                    // 3 terminals in thirds
                    if (i < 3) {
                        t.element.style.left = (pad + i * (w/3 + pad/3)) + 'px';
                        t.element.style.top = pad + 'px';
                        t.element.style.width = (w/3 - pad*1.3) + 'px';
                        t.element.style.height = (h - pad*2) + 'px';
                    }
                } else {
                    // Cascade
                    t.element.style.left = (30 + i * 30) + 'px';
                    t.element.style.top = (30 + i * 30) + 'px';
                    t.element.style.width = '500px';
                    t.element.style.height = '350px';
                }
                
                setTimeout(() => t.element.classList.remove('snapping'), 250);
            });
        }

        // Snap button in taskbar
        document.getElementById('snap-layout-btn')?.addEventListener('click', () => {
            if (activeTerminal) {
                showSnapOverlay(activeTerminal);
            }
        });

        // Close snap overlay on click outside or Escape
        snapOverlay?.addEventListener('click', (e) => {
            if (e.target === snapOverlay) hideSnapOverlay();
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && snapOverlay?.classList.contains('active')) hideSnapOverlay();
            // Win+Z or Ctrl+Shift+Z to open snap layouts (Windows 11 style)
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                if (activeTerminal) showSnapOverlay(activeTerminal);
            }
        });

        // Handle snap zone hover and click
        document.querySelectorAll('.snap-layout-preview div').forEach(zone => {
            zone.addEventListener('mouseenter', () => {
                // Highlight this zone
                zone.classList.add('highlight');
            });
            zone.addEventListener('mouseleave', () => {
                zone.classList.remove('highlight');
            });
            zone.addEventListener('click', (e) => {
                e.stopPropagation();
                const snapZone = zone.dataset.snap;
                if (snapZone) applySnapLayout(snapZone);
            });
        });

        // Click layout option to arrange ALL visible terminals
        document.querySelectorAll('.snap-layout-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const layoutType = option.dataset.layout;
                if (layoutType) {
                    arrangeAllTerminals(layoutType);
                    hideSnapOverlay();
                }
            });
        });
        
        // Arrange all visible terminals based on layout type
        function arrangeAllTerminals(layoutType) {
            const visible = terminals.filter(t => !t.element.classList.contains('minimized'));
            if (visible.length === 0) return;
            
            // Track current layout for responsive adjustments
            currentLayout = layoutType;
            
            const ws = document.getElementById('workspace');
            const rect = ws.getBoundingClientRect();
            const w = rect.width, h = rect.height, pad = 8;
            
            visible.forEach((t, i) => {
                t.element.classList.remove('maximized');
                t.element.style.zIndex = '';
                t.element.classList.add('snapping');
            });
            
            if (layoutType === 'full') {
                // Full screen - only first terminal
                if (visible[0]) {
                    visible[0].element.style.left = pad + 'px';
                    visible[0].element.style.top = pad + 'px';
                    visible[0].element.style.width = (w - pad*2) + 'px';
                    visible[0].element.style.height = (h - pad*2) + 'px';
                    visible[0].activate();
                }
                // Minimize others
                visible.slice(1).forEach(t => {
                    t.element.classList.add('minimized');
                    t.updateTaskbar();
                });
            } else if (layoutType === 'half') {
                // 2 columns - distribute terminals
                visible.forEach((t, i) => {
                    const col = i % 2;
                    const row = Math.floor(i / 2);
                    const rowCount = Math.ceil(visible.length / 2);
                    const cellH = (h - pad * (rowCount + 1)) / rowCount;
                    
                    t.element.style.left = (col === 0 ? pad : w/2 + pad/2) + 'px';
                    t.element.style.top = (pad + row * (cellH + pad)) + 'px';
                    t.element.style.width = (w/2 - pad*1.5) + 'px';
                    t.element.style.height = cellH + 'px';
                });
            } else if (layoutType === 'thirds') {
                // 3 columns - distribute terminals
                visible.forEach((t, i) => {
                    const col = i % 3;
                    const row = Math.floor(i / 3);
                    const rowCount = Math.ceil(visible.length / 3);
                    const cellH = (h - pad * (rowCount + 1)) / rowCount;
                    const cellW = (w - pad * 4) / 3;
                    
                    t.element.style.left = (pad + col * (cellW + pad)) + 'px';
                    t.element.style.top = (pad + row * (cellH + pad)) + 'px';
                    t.element.style.width = cellW + 'px';
                    t.element.style.height = cellH + 'px';
                });
            } else if (layoutType === 'quarters') {
                // 4 quadrants - distribute terminals
                visible.forEach((t, i) => {
                    const col = i % 2;
                    const row = Math.floor(i / 2) % 2;
                    const page = Math.floor(i / 4);
                    
                    if (page === 0) {
                        t.element.style.left = (col === 0 ? pad : w/2 + pad/2) + 'px';
                        t.element.style.top = (row === 0 ? pad : h/2 + pad/2) + 'px';
                        t.element.style.width = (w/2 - pad*1.5) + 'px';
                        t.element.style.height = (h/2 - pad*1.5) + 'px';
                    } else {
                        // Extra terminals cascade
                        t.element.style.left = (50 + (i-4) * 30) + 'px';
                        t.element.style.top = (50 + (i-4) * 30) + 'px';
                        t.element.style.width = '450px';
                        t.element.style.height = '300px';
                    }
                });
            } else if (layoutType === 'left-large') {
                // Left 2/3, right 1/3 stacked
                if (visible[0]) {
                    visible[0].element.style.left = pad + 'px';
                    visible[0].element.style.top = pad + 'px';
                    visible[0].element.style.width = (w*2/3 - pad*1.5) + 'px';
                    visible[0].element.style.height = (h - pad*2) + 'px';
                }
                // Stack remaining on right
                const rightTerms = visible.slice(1);
                if (rightTerms.length > 0) {
                    const cellH = (h - pad * (rightTerms.length + 1)) / rightTerms.length;
                    rightTerms.forEach((t, i) => {
                        t.element.style.left = (w*2/3 + pad/2) + 'px';
                        t.element.style.top = (pad + i * (cellH + pad)) + 'px';
                        t.element.style.width = (w/3 - pad*1.3) + 'px';
                        t.element.style.height = cellH + 'px';
                    });
                }
            }
            
            // Remove snapping class after animation
            setTimeout(() => {
                visible.forEach(t => t.element.classList.remove('snapping'));
            }, 300);
        }

        // Available commands
        const commands = {
            '/help': {
                description: 'Show all available commands',
                execute: () => {
                    return `<div class="command-help">
                        <div class="command-help-title">📋 Available Commands:</div>

                        <div style="margin-top: 15px; color: #000000; font-weight: 700;"><i class="fas fa-shield-alt"></i> Attack Simulation:</div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/attack</span>
                            <span class="command-help-desc">Simulate 10 random attacks</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/attack &lt;type&gt;</span>
                            <span class="command-help-desc">Simulate specific attack (dos, fuzzers, exploits...)</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/attacks</span>
                            <span class="command-help-desc">List available attack types</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/simulate &lt;n&gt;</span>
                            <span class="command-help-desc">Simulate N random attacks (1-50)</span>
                        </div>

                        <div style="margin-top: 15px; color: #000000; font-weight: 700;"><i class="fas fa-network-wired"></i> PCAP Analysis:</div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/zeek-pcap</span>
                            <span class="command-help-desc">List available PCAP files</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/zeek-pcap &lt;file&gt;</span>
                            <span class="command-help-desc">Analyze PCAP with Zeek + ML</span>
                        </div>

                        <div style="margin-top: 15px; color: #000000; font-weight: 700;"><i class="fas fa-cog"></i> System:</div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/status</span>
                            <span class="command-help-desc">Show system status</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/stats</span>
                            <span class="command-help-desc">Show statistics</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/clear</span>
                            <span class="command-help-desc">Clear all alerts and state</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/export json|csv</span>
                            <span class="command-help-desc">Export alerts to file</span>
                        </div>

                        <div style="margin-top: 15px; color: #000000; font-weight: 700;"><i class="fas fa-window-maximize"></i> Terminal:</div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/open &lt;type&gt;</span>
                            <span class="command-help-desc">Open terminal (monitor/attack)</span>
                        </div>
                        <div class="command-help-item">
                            <span class="command-help-cmd">/closeall</span>
                            <span class="command-help-desc">Close all terminal windows</span>
                        </div>
                    </div>`;
                }
            },
            '/open': {
                description: 'Open a terminal (monitor, attack)',
                execute: (args) => {
                    const type = args[0]?.toLowerCase();
                    const terminalConfigs = {
                        monitor: { type: 'monitor', title: 'Network Monitor' },
                        attack: { type: 'attack', title: 'Attack Logs' }
                    };

                    if (terminalConfigs[type]) {
                        const config = terminalConfigs[type];
                        let existingTerm = terminals.find(t => t.type === config.type);
                        if (existingTerm) {
                            existingTerm.element.classList.add('no-animation');
                            existingTerm.activate();
                            setTimeout(() => existingTerm.element.classList.remove('no-animation'), 50);
                            return `<span class="success"><i class="fas fa-check"></i> ${config.title}</span>`;
                        }
                        const x = 100 + Math.random() * 200;
                        const y = 100 + Math.random() * 150;
                        new Terminal(config.type, config.title, x, y, { activate: true });
                        return `<span class="success"><i class="fas fa-check"></i> Opened ${config.title}</span>`;
                    } else {
                        return `<span class="error">Usage: /open monitor | /open attack</span>`;
                    }
                }
            },
            '/closeall': {
                description: 'Close all terminals',
                execute: () => {
                    const count = terminals.length;
                    terminals.forEach(t => {
                        t.element.classList.add('closing');
                        const taskbarItem = document.getElementById('taskbar-' + t.id);
                        if (taskbarItem) taskbarItem.remove();
                    });
                    setTimeout(() => {
                        terminals.forEach(t => t.element.remove());
                        terminals.length = 0;
                    }, 200);
                    return `<span class="success"><i class="fas fa-check"></i> Closed ${count} terminal(s)</span>`;
                }
            }
        };

        let startTime = Date.now();

        // Process command
        function processCommand(input) {
            const trimmedInput = input.trim();
            
            // Ensure command starts with /
            if (!trimmedInput.startsWith('/')) {
                addCommandLine(`<span style="color: #00aa00;"><i class="fas fa-terminal"></i></span> ${input}`, 'info');
                addCommandLine(`<span class="error"><i class="fas fa-times"></i> Commands must start with /</span><br>` +
                              `<span style="color: #64748b;">Type '/help' for available commands</span>`, 'error');
                return;
            }

            const parts = trimmedInput.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            commandHistory.push(trimmedInput);
            historyIndex = commandHistory.length;

            // Add command to output
            addCommandLine(`<span style="color: #00aa00;"><i class="fas fa-terminal"></i></span> ${trimmedInput}`, 'info');

            // Route SOC commands to backend (whitelist only)
            if (SOC_COMMANDS.has(cmd)) {
                // Auto-open relevant terminals for SOC commands
                // so the user immediately sees the right streams.
                const openSocTerminalsFor = (fullLine) => {
                    // Remove deprecated SOC Status popup terminal if it exists.
                    closeSocStatusTerminal();
                    // Close processing terminal (not needed for most commands)
                    closeTerminalByType('processing');

                    const parts = String(fullLine || '').trim().split(/\s+/);
                    const head = (parts[0] || '').toLowerCase();
                    const sub = (parts[1] || '').toLowerCase();

                    const openAndActivate = (type, title) => {
                        let t = terminals.find(x => x.type === type);
                        if (!t) {
                            const x = 120 + Math.random() * 180;
                            const y = 110 + Math.random() * 140;
                            t = new Terminal(type, title, x, y, { activate: true });
                        } else {
                            t.element.classList.add('no-animation');
                            t.activate();
                            setTimeout(() => t.element.classList.remove('no-animation'), 50);
                        }
                        return t;
                    };

                    const openNoSteal = (type, title) => {
                        let t = terminals.find(x => x.type === type);
                        if (!t) {
                            const x = 120 + Math.random() * 180;
                            const y = 110 + Math.random() * 140;
                            t = new Terminal(type, title, x, y, { activate: false });
                        } else {
                            t.element.classList.add('no-animation');
                            setTimeout(() => t.element.classList.remove('no-animation'), 50);
                        }
                        return t;
                    };

                    // /status should not open a popup terminal.
                    if (head === '/status') return;

                    if (head === '/zeek' || head === '/zeek-pcap') {
                        // Auto-open the Network Monitor for Zeek commands
                        openAndActivate('monitor', 'Network Monitor');
                        return;
                    }

                    if (head === '/replay') {
                        // Replay => Network Monitor auto-opens.
                        openAndActivate('monitor', 'Network Monitor');
                        return;
                    }

                    if (head === '/attack' || head === '/attacks' || head === '/simulate' || head === '/attack-real') {
                        // Attack simulation => VM windows are created by vm_setup event from backend
                        // Also open Attack Logs to show ML predictions
                        openNoSteal('attack', 'Attack Logs');
                        // For /attack-real, also open Network Monitor since it uses Zeek
                        if (head === '/attack-real') {
                            openAndActivate('monitor', 'Network Monitor');
                        }
                        return;
                    }

                    // /export and /clear should not open any popup terminals.
                };

                if (cmd === '/clear') {
                    // Keep existing UX for clearing command output
                    commandOutput.innerHTML = '';

                    // Also clear all popup terminal windows (Network/Processing/Attack/etc)
                    try {
                        terminals.forEach(t => clearTerminal(t));
                    } catch {}
                }

                if (cmd === '/status') {
                    // Route the user to the Live Monitor navbar item.
                    setActiveNavByLabel('Live Monitor');
                }

                openSocTerminalsFor(trimmedInput);
                sendSocCommand(trimmedInput);
                return;
            }

            if (commands[cmd]) {
                const result = commands[cmd].execute(args);
                if (result) {
                    addCommandLine(result);
                }
            } else {
                addCommandLine(`<span class="error"><i class="fas fa-times"></i> Unknown command: ${cmd}</span><br>` +
                              `<span style="color: #64748b;">Type '/help' for available commands</span>`, 'error');
            }
        }

        // Add line to command output
        function addCommandLine(text, type = '') {
            const line = document.createElement('div');
            line.className = `command-line ${type}`;
            line.innerHTML = text;
            commandOutput.appendChild(line);
            commandOutput.scrollTop = commandOutput.scrollHeight;
        }

        // Handle command input
        commandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const input = commandInput.value.trim();
                if (input) {
                    if (!commandTerminal.classList.contains('expanded')) {
                        commandTerminal.classList.add('expanded');
                        commandToggle.textContent = '▼';
                        if (typeof setCommandTerminalHeight === 'function') {
                            setCommandTerminalHeight(lastExpandedHeight);
                        }
                    }
                    processCommand(input);
                    commandInput.value = '';
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    commandInput.value = '';
                }
            }
        });

        // Auto-focus command input when pressing any key (except when typing in other inputs)
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                if (e.key.length === 1 || e.key === 'Backspace') {
                    commandInput.focus();
                }
            }
        });
    </script>
</body>
</html>